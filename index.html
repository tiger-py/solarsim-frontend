<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<title>Solar Waves – Irradiance Explorer</title>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<style>
    :root {
      --bg: #f4f6fb;
      --sidebar-bg: #ffffff;
      --accent: #3fa51c;
      --accent-soft: #dff3d6;
      --border-subtle: #d3d8e4;
      --text-main: #222631;
      --text-muted: #6f7484;
      --panel-bg: #f9fafc;
      --error: #d93025;
      --success: #0f9d58;
      --radius-lg: 16px;
      --radius-sm: 8px;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: var(--text-main);
      background: var(--bg);
      overflow: hidden;
    }

    #app {
      display: grid;

      /* Base control width (left sidebar is 2× this) */
      --rightW: 300px;

      grid-template-columns: calc(var(--rightW) * 2) minmax(0, 1fr);
      /* Main viewport + results stacked in the right-hand column */
      grid-template-rows: minmax(0, 1fr) 260px;
      grid-template-areas:
        "sidebar main"
        "sidebar results";

      height: 100vh;
      width: 100vw;
    }

    #sidebar {
      grid-area: sidebar;
      background: var(--sidebar-bg);
      border-right: 1px solid var(--border-subtle);
      padding: 14px 14px 18px;

      /* Two cards side-by-side */
      display: flex;
      flex-direction: row;
      align-items: stretch;
      gap: 14px;

      font-size: 18px;
      height: 100vh;

      /* Sidebar itself should not scroll; cards will scroll */
      overflow: hidden;
      overscroll-behavior: contain;
      box-sizing: border-box;
    }

    /* Right results panel (mirrors sidebar) */
    #rightbar {
      grid-area: results;
      background: transparent;
      border-left: none;
      border-top: 1px solid var(--border-subtle);
      padding: 14px 14px 18px;
      display: flex;
      flex-direction: column;
      gap: 14px;
      overflow: hidden; /* panel doesn't scroll; card scrolls */
      box-sizing: border-box;
    }

    h2 {
      margin: 0 0 6px;
      font-size: 17px;
      letter-spacing: 0.04em;
      text-transform: uppercase;
      color: var(--text-muted);
    }

    .card {
      background: var(--panel-bg);
      border-radius: var(--radius-lg);
      padding: 10px 10px 12px;
      border: 1px solid var(--border-subtle);
    }

    /* In the sidebar, make each top-level card fill height and scroll internally */
    #sidebar > .card {
      flex: 1 1 0;
      min-width: 0;        /* important: prevents overflow pushing layout wider */
      height: 100%;
      overflow-y: auto;    /* each card scrolls if needed */
    }

    /* Was useful for vertical stacking, but for horizontal layout it adds odd spacing */
    #sidebar .card + .card {
      margin-top: 0;
    }

    .card + .card { margin-top: 4px; }

    label {
      display: block;
      font-size: 15px;
      font-weight: 500;
      color: var(--text-muted);
      margin-bottom: 2px;
    }

    input[type="text"] {
      width: 100%;
      padding: 5px 7px;
      border-radius: 999px;
      border: 1px solid var(--border-subtle);
      font-size: 15px;
      outline: none;
    }

    input[type="text"]:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px var(--accent-soft);
    }

    button {
      border-radius: 999px;
      border: none;
      background: var(--accent);
      color: #fff;
      font-size: 15px;
      padding: 5px 10px;
      cursor: pointer;
      white-space: nowrap;
    }

    button:disabled {
      opacity: 0.6;
      cursor: default;
    }

    .row {
      display: flex;
      align-items: center;
      gap: 6px;
      margin-bottom: 4px;
    }

    .row.stacked {
      flex-direction: column;
      align-items: stretch;
    }

    select {
      width: 100%;
      padding: 4px 6px;
      border-radius: 999px;
      border: 1px solid var(--border-subtle);
      font-size: 15px;
      background: #fff;
    }

    .metric-list {
      list-style: none;
      padding: 0;
      margin: 0;
      font-size: 15px;
      color: var(--text-muted);
    }

    .metric-list li {
      display: flex;
      justify-content: space-between;
      margin-bottom: 6px;
    }

    .metric-label { color: var(--text-muted); }
    .metric-value { font-weight: 500; color: var(--text-main); }

    .slider-block {
      margin-bottom: 8px;
    }

    .slider-header {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      font-size: 15px;
      margin-bottom: 2px;
    }

    .slider-header span.value {
      color: var(--text-muted);
      font-variant-numeric: tabular-nums;
    }

    input[type="range"] {
      width: 100%;
      margin: 0;
    }

    /* Slider styling (match accent colour) */
    input[type="range"]{
      accent-color: var(--accent);
    }
    input[type="range"]::-webkit-slider-runnable-track{
      height: 4px;
      border-radius: 999px;
      background: rgba(34, 38, 49, 0.18);
    }
    input[type="range"]::-webkit-slider-thumb{
      -webkit-appearance: none;
      appearance: none;
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: var(--accent);
      border: 2px solid #ffffff;
      margin-top: -5px;
      box-shadow: 0 1px 6px rgba(0,0,0,0.25);
      cursor: pointer;
    }
    input[type="range"]::-moz-range-track{
      height: 4px;
      border-radius: 999px;
      background: rgba(34, 38, 49, 0.18);
    }
    input[type="range"]::-moz-range-thumb{
      width: 14px;
      height: 14px;
      border-radius: 50%;
      background: var(--accent);
      border: 2px solid #ffffff;
      box-shadow: 0 1px 6px rgba(0,0,0,0.25);
      cursor: pointer;
    }
    
    .small-note {
      font-size: 14px;
      color: var(--text-muted);
      line-height: 1.4;
      margin-top: 4px;
    }
.checkbox-row {
  margin-top: 6px;
  margin-bottom: 8px;
  font-size: 18px;
  color: var(--text-muted);
  user-select: none;
}
.checkbox-row input[type="checkbox"] {
  transform: translateY(1px);
  margin-right: 6px;
}



    #simError {
      display: none;
      margin-top: 4px;
      padding: 4px 6px;
      border-radius: var(--radius-sm);
      background: #fdecea;
      color: var(--error);
      font-size: 12px;
    }

    #simStatus {
      font-size: 12px;
      color: var(--text-muted);
      margin-top: 2px;
    
      display: none !important;
      margin: 0 !important;
      padding: 0 !important;
    }

    /* Main 3D area */
    #main {
      grid-area: main;
      position: relative;
      background: #d2d6df;
    }

    /* Results card (right panel, green theme) */
    .results-card{
      /* no longer overlay */
      position: relative;
      inset: auto;
      width: auto;
      z-index: auto;

      /* Fill the results row */
      height: 100%;
      overflow-y: auto;

      /* original green styling */
      background: var(--accent);
      border: 1px solid rgba(0, 0, 0, 0.08);
      border-radius: var(--radius-lg);
      color: #ffffff;
    }

    /* Typography inside results card */
    .results-card h2{
      color: rgba(255,255,255,0.9);
    }

    .results-card .metric-label{
      color: rgba(255,255,255,0.9);
    }

    .results-card .metric-value{
      color: #ffffff;
    }

    .results-card .small-note{
      color: rgba(255,255,255,0.9);
    }

    /* Button styling (white button on green background) */
    .results-card button{
      background: #ffffff;
      color: var(--accent);
      border: none;
    }


    #canvasContainer {
      position: absolute;
      inset: 0;
    }

    /* Legend */
    #legend {
      position: absolute;
      top: 10px;
      right: 10px;
      width: 180px;
      background: rgba(255, 255, 255, 0.96);
      backdrop-filter: blur(4px);
      padding: 8px 10px;
      border-radius: var(--radius-lg);
      border: 1px solid var(--border-subtle);
      font-size: 12px;
      color: var(--text-muted);
    }

    #legend-title {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      margin-bottom: 4px;
      font-size: 12px;
      font-weight: 600;
      color: var(--text-main);
    }

    #legend-bar {
      position: relative;
      height: 6px;
      border-radius: 999px;
      background: linear-gradient(to right, #2b7bff, #35c88a, #f2c744, #ff6a3d);
      margin-bottom: 4px;
      overflow: hidden;
    }

    #legend-min,
    #legend-max {
      display: inline-block;
      font-variant-numeric: tabular-nums;
    }

    #legend-footer {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    #legend-footer .legend-note {
      font-size: 12px;
      color: var(--text-muted);
      line-height: 1.2;
    }

    #legend-footer .legend-scale {
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    #snapshotTooltip {
      position: fixed;
      pointer-events: none;
      background: rgba(15, 17, 26, 0.9);
      color: #fff;
      padding: 6px 8px;
      border-radius: 6px;
      font-size: 13px;
      line-height: 1.4;
      z-index: 50;
      opacity: 0;
      transition: opacity 0.15s ease;
      max-width: 220px;
    }

    #locationModal {
      position: absolute;
      inset: 0;
      background: rgba(15, 17, 26, 0.35);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 20;
    }

    #locationModalInner {
      background: #fff;
      border-radius: var(--radius-lg);
      padding: 10px 12px;
      width: 260px;
      box-shadow: 0 10px 30px rgba(15, 17, 26, 0.35);
      font-size: 13px;
    }

    #locationList {
      max-height: 200px;
      overflow-y: auto;
      margin: 6px 0 8px;
      padding: 0;
      list-style: none;
    }

    #locationList li {
      margin-bottom: 4px;
    }

    #locationList label {
      display: flex;
      gap: 4px;
      cursor: pointer;
      margin-bottom: 0;
    }

    #locationList span {
      flex: 1;
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
    }

    #locationModalActions {
      display: flex;
      justify-content: flex-end;
      gap: 6px;
    }

    /* Misc */
    .pill {
      display: inline-flex;
      align-items: center;
      padding: 0 6px;
      height: 16px;
      border-radius: 999px;
      background: #eef2ff;
      font-size: 14px;
      color: #4c5fd7;
    }
  
    .metric-list li { gap: 8px; }
    .metric-label { padding-right: 6px; }
    .metric-value { padding-left: 6px; text-align: right; min-width: 0; overflow-wrap: anywhere; }


    .loading-pill{
      display:flex;
      align-items:center;
      gap:10px;
      margin-top:10px;
      padding:10px 12px;
      border:1px solid var(--accent);
      background: var(--accent-soft);
      border-radius: 12px;
      color: var(--text-main);
      font-size: 18px;
      line-height: 1.3;
    }

    .spinner{
      width: 14px;
      height: 14px;
      border-radius: 50%;
      border: 2px solid rgba(63, 165, 28, 0.25);
      border-top-color: var(--accent);
      animation: spin 0.9s linear infinite;
      flex: 0 0 auto;
    }

    @keyframes spin { from { transform: rotate(0deg);} to { transform: rotate(360deg);} }


    /* --- Map picker (Leaflet) --- */
    .map-picker {
      height: 220px; /* adjust as desired */
      border-radius: 12px;
      overflow: hidden;
      border: 1px solid rgba(255,255,255,0.12);
      background: rgba(0,0,0,0.25);
    }

    .map-picker .leaflet-control {
      box-shadow: none;
      border: 1px solid rgba(255,255,255,0.12);
    }

    /* Map card note only (avoid overriding sidebar notes elsewhere) */
    .map-note{
      margin-top: 8px;
      font-size: 14px;
      color: var(--text-muted);
      line-height: 1.4;
    }

    /* Keep the location status pill visible after a selection completes */
    .loading-pill.success{
      background: var(--accent-soft);
      border-color: var(--accent);
    }
    .loading-pill.success .spinner{ display: none; }


    /* ------------------------------------------------------------
       Initial loading overlay (Option A)
       ------------------------------------------------------------ */
    #loadingOverlay {
      position: fixed;
      inset: 0;
      z-index: 9999;
      display: flex;
      align-items: center;
      justify-content: center;
      background: rgba(255, 255, 255, 0.72);
      backdrop-filter: blur(4px);
      -webkit-backdrop-filter: blur(4px);
      transition: opacity 320ms ease;
    }
    #loadingOverlay.hidden {
      opacity: 0;
      pointer-events: none;
    }
    .loading-card {
      width: min(420px, calc(100vw - 48px));
      border-radius: 16px;
      padding: 22px 22px 18px 22px;
      background: var(--accent);
      border: 1px solid rgba(0, 0, 0, 0.08);
      box-shadow: 0 14px 50px rgba(0, 0, 0, 0.45);
      color: #ffffff;
      text-align: left;
    }
    .loading-title {
      font-size: 22px;
      font-weight: 700;
      letter-spacing: 0.2px;
      margin-bottom: 10px;
    }
    .loading-status {
      font-size: 18px;
      opacity: 0.92;
      margin-bottom: 14px;
      line-height: 1.35;
    }
    .loading-bar-wrap {
      height: 10px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.35);
      overflow: hidden;
      border: 1px solid rgba(255, 255, 255, 0.10);
    }
    .loading-bar {
      height: 100%;
      width: 0%;
      background: rgba(255, 255, 255, 0.95);
      transition: width 140ms ease;
    }
    .loading-percent {
      margin-top: 10px;
      font-size: 18px;
      opacity: 0.82;
    }

    /* Hide canvas until first clean render is ready (prevents half-built visuals) */
    #canvasContainer {
      opacity: 0;
      transition: opacity 260ms ease;
    }
    #canvasContainer.ready {
      opacity: 1;
    }
</style>
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"/>
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

</head>
<body>
<div id="loadingOverlay" aria-live="polite" aria-busy="true">
  <div class="loading-card">
    <div class="loading-title">Power Output and Water Savings Simulation</div>
    <div id="loadingStatus" class="loading-status">Loading textures…</div>
    <div class="loading-bar-wrap" role="progressbar" aria-valuemin="0" aria-valuemax="100" aria-valuenow="0">
      <div id="loadingBar" class="loading-bar"></div>
    </div>
    <div id="loadingPercent" class="loading-percent">0%</div>
  </div>
</div>
<div id="app">
<aside id="sidebar">
<div class="card">
<h2>Location - World Wide</h2>
<div id="mapPicker" class="map-picker" aria-label="World map location picker"></div>
<div class="map-note">Click the map to select a location.</div>
<div id="locationLoading" class="loading-pill" style="display:none;">
  <span class="spinner" aria-hidden="true"></span>
  <span id="locationLoadingText">Searching…</span>
</div>
<div class="small-note" id="locationStatus">No location selected.</div>
<ul class="metric-list" style="margin-top:4px;">
<li><span class="metric-label">Latitude:</span><span class="metric-value" id="metricLat">–</span></li>
<li><span class="metric-label">Longitude:</span><span class="metric-value" id="metricLon">–</span></li>
</ul>
</div>

<div class="card">
<h2>Type of Solar Array</h2>
<div class="row stacked">
<label for="arrayType">Array type</label>
<select id="arrayType">
<option value="waves">Solar Waves</option>
<option value="roof">Solar Canopy</option>
</select>
</div>
<div class="row stacked">
<label for="panelType">Panel type</label>
<select id="panelType"></select>
</div>
<div id="wavesControls">
<div class="slider-block">
<div class="slider-header">
<span>Panels per row</span>
<span class="value"><span id="wavesPanelsPerRowVal">5</span></span>
</div>
<input id="wavesPanelsPerRow" max="8" min="3" step="1" type="range" value="5"/>
</div>
</div>
<div id="roofControls" style="display:none;">
<div class="slider-block">
<div class="slider-header">
<span>Number of Solar Panels wide</span>
<span class="value"><span id="roofColsVal">20</span></span>
</div>
<input id="roofCols" max="24" min="4" step="1" type="range" value="20"/>
</div>
<div class="slider-block">
<div class="slider-header">
<span>Number of Solar Panels long</span>
<span class="value"><span id="roofRowsVal">4</span></span>
</div>
<input id="roofRows" max="8" min="1" step="1" type="range" value="4"/>
</div>
<div class="slider-block">
<div class="slider-header">
<span>Canopy angle (in degrees)</span>
<span class="value"><span id="roofTiltVal">15°</span></span>
</div>
<input id="roofTilt" max="40" min="0" step="1" type="range" value="15"/>
</div>
</div>
<div class="slider-block">
<div class="slider-header">
<span>Rotation relative to North (in degrees)</span>
<span class="value"><span id="azimuthVal">180°</span></span>
</div>
<input id="azimuth" max="360" min="0" step="1" type="range" value="180"/>
</div>
<div class="slider-block">
<div class="slider-header">
<span>Height above ground (in meters)</span>
<span class="value"><span id="elevationVal">0.6 m</span></span>
</div>
<input id="elevation" max="10.0" min="0.0" step="0.1" type="range" value="0.6"/>
</div>
<div id="groundTilingControls" style="margin-top:8px;">
  <div id="groundTilingControls">

  <div class="slider-block">
    <div class="slider-header">
      <span>Number of Arrays (East - West)</span>
      <span class="value"><span id="groundArrayXVal">1</span></span>
    </div>
    <input id="groundArrayX" max="10" min="1" step="1" type="range" value="1"/>
  </div>
  <div class="slider-block">
    <div class="slider-header">
      <span>Number of Arrays (North - South)</span>
      <span class="value"><span id="groundArrayYVal">1</span></span>
    </div>
    <input id="groundArrayY" max="10" min="1" step="1" type="range" value="1"/>
  </div>
  </div>
</div>
<div class="row stacked">
<label for="surfaceType">On Ground or over Water</label>
<select id="surfaceType">
<option selected="" value="ground">On Ground</option>
<option value="water">Over Water</option>
</select>
</div>
<div class="slider-block" id="waterWidthRow" style="display:none;">
<div class="slider-header">
<span>Water width (m)</span>
<span class="value"><span id="waterWidthVal">5.0 m</span></span>
</div>
<input id="waterWidth" max="20.0" min="1.0" step="0.5" type="range" value="5.0"/>
</div>
<div id="simError"></div>
</div>
</aside>
<main id="main">
<div id="canvasContainer"></div>
<div id="locationModal">
<div id="locationModalInner">
<div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:4px;">
<div style="font-weight:600;">Select a location</div>
<span class="pill" id="locationModalProvider"></span>
</div>
<ul id="locationList"></ul>
<div id="locationModalActions">
<button id="locationModalCancel">Cancel</button>
<button id="locationModalApply">Apply</button>
</div>
</div>
</div>
</main>
<aside id="rightbar">
  <section id="resultsCard" class="card results-card">
    <h2>Results</h2>
    <ul class="metric-list" style="margin-top:4px;">
      <li><span class="metric-label">Total panels:</span><span class="metric-value" id="metricPanels">–</span></li>
      <li><span class="metric-label">Power generated over one year:</span><span class="metric-value" id="metricAnnual">–</span></li>
      <li><span class="metric-label">Water saved by shading over one year:</span><span class="metric-value" id="metricWaterSaved">–</span></li>
      <li id="metricWaterCollectedRow" style="display:none;"><span class="metric-label">Rainwater collected over one year:</span><span class="metric-value" id="metricWaterCollected">–</span></li>
    </ul>
    <div class="small-note" id="resultsStatus" style="margin-top:8px;color: var(--text-muted);"></div>

    <div class="row" style="margin-top:14px;">
      <button disabled="" id="downloadBtn">Download simulation data</button>
    </div>
    <div class="small-note" id="downloadHint">Exports an audit pack ZIP for Water runs (includes shading samples + SVF).</div>
  </section>
</aside>
</div>
<script src="https://unpkg.com/three@0.140.0/build/three.min.js"></script>
<script src="https://unpkg.com/three@0.140.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://unpkg.com/three@0.140.0/examples/js/loaders/RGBELoader.js"></script>
<script>
    console.log("✅ INDEX BUILD MARKER", new Date().toISOString(), "URL=", location.href);
    (function() {
      const API_BASE = (() => {
    // Allow overriding the API base via ?api=http://127.0.0.1:8000 (useful for local/offline testing)
    try {
      const qs = new URLSearchParams(window.location.search || "");
      const forced = qs.get("api");
      if (forced) return String(forced).replace(/\/+$/g, "");
    } catch (_) {}

    const host = (window.location && window.location.hostname) ? window.location.hostname : "";
    if (host === "localhost" || host === "127.0.0.1") return "http://127.0.0.1:8000";
    return "https://sw-api-sn0k.onrender.com";
  })();

  console.log("[API] API_BASE =", API_BASE);
const DEBUG_FRAME = false;
function dbgFrame(...args){ if (DEBUG_FRAME) console.log("[frame]", ...args); }
// --- Real-time irradiance (hourly) via Open-Meteo (frontend) ------------------
// Goal: in "real-time" mode, drive panel colors with physically interpretable W/m²,
// then apply GPU-derived beam transmittance (tau) as a shadow mask.

const REALTIME_METEO_TTL_MS = 10 * 60 * 1000; // refresh at most every 10 minutes
let realtimeMeteoCache = null; // { tsMs: number[], dni: number[], dhi: number[], ghi: number[] }
let realtimeMeteoLastFetchMs = 0;
let realtimeMeteoInFlight = null;

function _asNumArray(a) {
  return Array.isArray(a) ? a.map(v => (v == null ? null : Number(v))) : null;
}

async function fetchRealtimeMeteoHourly(lat, lon) {
  // Use UTC to keep indexing consistent with our sun position function (UTC-based).
  // Prefer DNI + DHI + GHI if available; fallback to "shortwave_radiation" as GHI.
  const url =
    "https://api.open-meteo.com/v1/forecast" +
    "?latitude=" + encodeURIComponent(lat) +
    "&longitude=" + encodeURIComponent(lon) +
    "&hourly=direct_normal_irradiance,diffuse_radiation,shortwave_radiation" +
    "&timezone=UTC";

  const resp = await fetch(url);
  if (!resp.ok) throw new Error("Open-Meteo HTTP " + resp.status);
  const j = await resp.json();
  const h = j && j.hourly ? j.hourly : null;
  if (!h || !Array.isArray(h.time)) throw new Error("Open-Meteo: missing hourly.time");

  const tsMs = h.time.map(t => Date.parse(t + "Z")); // Open-Meteo returns ISO without Z in UTC mode
  const dni = _asNumArray(h.direct_normal_irradiance);
  const dhi = _asNumArray(h.diffuse_radiation);
  const ghi = _asNumArray(h.shortwave_radiation);

  if (!dni || !dhi || !ghi) throw new Error("Open-Meteo: missing irradiance series");

  realtimeMeteoCache = { tsMs, dni, dhi, ghi };
  realtimeMeteoLastFetchMs = Date.now();
  realtimeMeteoInFlight = null;
  return realtimeMeteoCache;
}

function ensureRealtimeMeteo() {
  if (!currentLocation) return;
  const now = Date.now();
  const fresh = realtimeMeteoCache && (now - realtimeMeteoLastFetchMs) < REALTIME_METEO_TTL_MS;
  if (fresh) return;

  if (realtimeMeteoInFlight) return;
  realtimeMeteoInFlight = fetchRealtimeMeteoHourly(currentLocation.lat, currentLocation.lon)
    .catch(err => {
      console.warn("Realtime meteo fetch failed:", err);
      realtimeMeteoInFlight = null;
    });
}

function getIrradianceAtUTC(dateObj) {
  if (!realtimeMeteoCache || !realtimeMeteoCache.tsMs || realtimeMeteoCache.tsMs.length === 0) return null;
  const t = dateObj instanceof Date ? dateObj.getTime() : Number(dateObj);
  if (!Number.isFinite(t)) return null;

  // Find nearest hour index (ts is hourly so linear scan is fine; arrays are ~168 long).
  const ts = realtimeMeteoCache.tsMs;
  let bestI = 0;
  let bestD = Math.abs(ts[0] - t);
  for (let i = 1; i < ts.length; i++) {
    const d = Math.abs(ts[i] - t);
    if (d < bestD) { bestD = d; bestI = i; }
  }
  return {
    dni: realtimeMeteoCache.dni[bestI],
    dhi: realtimeMeteoCache.dhi[bestI],
    ghi: realtimeMeteoCache.ghi[bestI]
  };
}

function computePOA_Wm2_fromIrradiance(nWorld, sunRay, irr, surfaceType) {
  // nWorld: surface normal, sunRay: unit vector from surface toward sun (same convention as cosInc below)
  // irr: {dni, dhi, ghi} at current hour
  if (!irr) return null;

  const dni = Number(irr.dni);
  const dhi = Number(irr.dhi);
  const ghi = Number(irr.ghi);
  if (!Number.isFinite(dni) || !Number.isFinite(dhi) || !Number.isFinite(ghi)) return null;

  // Incidence term
  const cosInc = Math.max(0, nWorld.dot(sunRay));

  // Tilt (0 = horizontal up, 90 = vertical) from normal vs +Y
  const cosTilt = THREE.MathUtils.clamp(nWorld.y, -1, 1);

  // Simple isotropic sky diffuse + ground-reflected component.
  // Albedo heuristic: water lower than ground.
  const albedo = (String(surfaceType || "").toLowerCase() === "water") ? 0.06 : 0.20;

  const beam = dni * cosInc;
  const diffuse = dhi * (1 + cosTilt) * 0.5;
  const groundRef = ghi * albedo * (1 - cosTilt) * 0.5;

  const poa = beam + diffuse + groundRef;
  return Math.max(0, poa);
}
// -----------------------------------------------------------------------------


      // DOM
      const canvasContainer = document.getElementById("canvasContainer");


      // ------------------------------------------------------------
      // Initial loading overlay (Option A)
      // ------------------------------------------------------------
      const loadingOverlayEl = document.getElementById("loadingOverlay");
      const loadingStatusEl = document.getElementById("loadingStatus");
      const loadingBarEl = document.getElementById("loadingBar");
      const loadingPercentEl = document.getElementById("loadingPercent");

      let __firstVisualReady = false;

      let __progressFloor = 0;

      function setLoadingStatus(msg) {
        if (!loadingStatusEl) return;
        loadingStatusEl.textContent = msg || "";
      }

      function setLoadingProgress(ratio01) {
        const r0 = Math.max(0, Math.min(1, Number(ratio01 || 0)));
        const r = Math.max(__progressFloor, r0);
        __progressFloor = r;
        const pct = Math.round(r * 100);
        if (loadingBarEl) loadingBarEl.style.width = pct + "%";
        if (loadingPercentEl) loadingPercentEl.textContent = pct + "%";
        if (loadingOverlayEl) {
          const pb = loadingOverlayEl.querySelector('.loading-bar-wrap');
          if (pb) pb.setAttribute("aria-valuenow", String(pct));
        }
      }

      function markFirstVisualReady() {
        if (__firstVisualReady) return;
        __firstVisualReady = true;

        // Ensure the final, textured scene has been presented at least once.
        requestAnimationFrame(() => {
          requestAnimationFrame(() => {
            try { canvasContainer.classList.add("ready"); } catch (_) {}
            if (loadingOverlayEl) {
              loadingOverlayEl.classList.add("hidden");
              loadingOverlayEl.setAttribute("aria-busy", "false");
              // remove from flow after fade to avoid intercepting clicks
              setTimeout(() => {
                try { loadingOverlayEl.style.display = "none"; } catch (_) {}
              }, 380);
            }
          });
        });
      }

      // One shared loading manager for texture + HDR assets (enables real progress).
      const _loadingManager = new THREE.LoadingManager();
      _loadingManager.onStart = () => {
        // Do not reset progress on subsequent batches; keep it monotonic for initial load.
        if (__progressFloor <= 0) setLoadingProgress(0);
      };
      _loadingManager.onProgress = (url, itemsLoaded, itemsTotal) => {
        if (itemsTotal && itemsTotal > 0) setLoadingProgress(itemsLoaded / itemsTotal);
      };
      _loadingManager.onLoad = () => {
        setLoadingProgress(1);
      };

      // Default overlay text
      setLoadingStatus("Loading textures…");
      setLoadingProgress(0);

      const mapPickerEl = document.getElementById("mapPicker");
      const locationStatusEl = document.getElementById("locationStatus");
      const locationLoadingEl = document.getElementById("locationLoading");
const locationLoadingTextEl = document.getElementById("locationLoadingText");
const metricLatEl = document.getElementById("metricLat");
      const metricLonEl = document.getElementById("metricLon");
      const metricPanelsEl = document.getElementById("metricPanels");
      const metricAnnualEl = document.getElementById("metricAnnual");
      const metricPOAEl = document.getElementById("metricPOA");
      const metricWaterSavedEl = document.getElementById("metricWaterSaved");
      
      const resultsStatusEl = document.getElementById("resultsStatus");
const downloadBtn = document.getElementById("downloadBtn");
      const downloadHint = document.getElementById("downloadHint");
      const arrayTypeEl = document.getElementById("arrayType");
      const panelTypeEl = document.getElementById("panelType");
      const wavesControlsEl = document.getElementById("wavesControls");
      const roofControlsEl = document.getElementById("roofControls");
      const wavesPanelsPerRowEl = document.getElementById("wavesPanelsPerRow");
      const wavesPanelsPerRowValEl = document.getElementById("wavesPanelsPerRowVal");
      const roofColsEl = document.getElementById("roofCols");
      const roofColsValEl = document.getElementById("roofColsVal");
      const roofRowsEl = document.getElementById("roofRows");
      const roofRowsValEl = document.getElementById("roofRowsVal");
      const roofTiltEl = document.getElementById("roofTilt");
      const roofTiltValEl = document.getElementById("roofTiltVal");
      const azimuthEl = document.getElementById("azimuth");
      const azimuthValEl = document.getElementById("azimuthVal");
      const elevationEl = document.getElementById("elevation");
      const elevationValEl = document.getElementById("elevationVal");

      // Ground-only: array duplication controls (array-of-arrays)
      const groundTilingControlsEl = document.getElementById("groundTilingControls");
      const groundArrayXEl = document.getElementById("groundArrayX");
      const groundArrayXValEl = document.getElementById("groundArrayXVal");
      const groundArrayYEl = document.getElementById("groundArrayY");
      const groundArrayYValEl = document.getElementById("groundArrayYVal");

      const surfaceTypeEl = document.getElementById("surfaceType");
const surfaceEl = surfaceTypeEl; // alias for legacy references

      const waterWidthEl = document.getElementById("waterWidth");
      const waterWidthValEl = document.getElementById("waterWidthVal");
      const waterWidthRowEl = document.getElementById("waterWidthRow");

      const simErrorEl = document.getElementById("simError");
      const simStatusEl = document.getElementById("simStatus");

      const legendMeanEl = document.getElementById("legend-mean");
      const legendNoteEl = document.querySelector("#legend-footer .legend-note");
      const legendMinEl = document.getElementById("legend-min");
      const legendMaxEl = document.getElementById("legend-max");

      // Location modal
      const locationModal = document.getElementById("locationModal");
      const locationModalProvider = document.getElementById("locationModalProvider");
      const locationListEl = document.getElementById("locationList");
      const locationModalCancelBtn = document.getElementById("locationModalCancel");
      const locationModalApplyBtn = document.getElementById("locationModalApply");

      // Three.js globals
      let scene, camera, renderer, controls;
      let groundMesh;
      let groundDims = { sx: 20, sz: 20 };
      let directionGroup;
      let northArrowGroup;
      let arrayGroup; // panels + edges

      // Overlay/debug visuals (disable by default for production UI)
      const SHOW_DIRECTION_MARKERS = false; // N/E/S/W disc sprites
      const SHOW_SNAPSHOT_CONTOURS = false; // snapshot bounding boxes + labels

      // --- GPU shadow/transmittance sampling (water/ground plane) ---
      let sunLight;
      let shadowRT, shadowCam, shadowMat, shadowReadBuf;
      let shadowOverlayMesh;
      let lastBeamTransmittanceUnderArray = 1.0;
      let lastBeamTransmittanceFull = 1.0;
      let _shadingJobToken = 0;
      let _finalShadingTimer = null;
      let shadowResInteractive = 128;
      let shadowResFinal = 512;
      let lastBeamTransmittance = 1.0;
      let lastSunAzDeg = 180.0, lastSunElDeg = 45.0;
      let _realtimeUpdateBusy = false;
      let _realtimeUpdateToken = 0;

      let panelMeshes = [];
      let basePanelMeshes = []; // base (single) array panels before ground tiling
      let baseArrayPrototype = null; // detached clone source for ground tiling (prevents scene graph recursion)
      // Expose live panel mesh list for console debugging (getter stays valid across rebuilds)
      try {
        Object.defineProperty(window, 'panelMeshes', { configurable: true, get: () => panelMeshes });
      } catch (e) {
        window.panelMeshes = panelMeshes;
      }
      let groundSize = 20;
      let waterWidthM = 5.0; // adjustable canal/lake width in meters (surface stays centered)
      // Track current surface dimensions for backend water-area computation
      let currentSurfaceSizeX = 0;
      let currentSurfaceSizeZ = 0;
      let currentWaterAreaM2 = 0;

      // Helper: compute water surface area in m² from current surface dimensions.
       // IMPORTANT: Must be top-level (not inside a click handler), because
       // runSimulationAndUpdateUI() calls it. :contentReference[oaicite:4]{index=4}
       function getWaterAreaM2Safe() {
         try {
           const surface =
             (surfaceTypeEl && surfaceTypeEl.value)
               ? String(surfaceTypeEl.value).toLowerCase()
               : "ground";
           if (surface !== "water") return 0.0;
 
           // Prefer the already-updated cached area (fast + consistent)
           const a = Number(currentWaterAreaM2);
           if (Number.isFinite(a) && a > 0) return a;
 
           // Fallback: compute from cached dimensions if area not set yet
           const sx = Number(currentSurfaceSizeX);
           const sz = Number(currentSurfaceSizeZ);
           if (Number.isFinite(sx) && Number.isFinite(sz) && sx > 0 && sz > 0) return sx * sz;
         } catch (_) {}
         return 0.0;
       }

      // Shadow mask storage (GPU readback) for per-panel / ground visualization
      let lastShadowMaskPixels = null;
      let lastShadowMaskW = 0, lastShadowMaskH = 0;
      let groundShadowTexture = null;

      let waterShadowTexture = null;
        

      // ------------------------------------------------------------
      // Water shadow mask ownership / invalidation
      // ------------------------------------------------------------
      // When Surface=Water, we sample a low-res shadow mask texture for per-panel shading.
      // That mask must never "bleed" between array types (waves/roof) or after geometry changes,
      // otherwise colors can appear swapped or panels can be mis-mapped.
      let lastShadowMaskOwnerKey = null;
      let lastShadowMaskOwnerType = null; // "waves" | "roof"
      const waterMaskStateByType = {
        waves: { key: null, pixels: null, w: 0, h: 0 },
        roof:  { key: null, pixels: null, w: 0, h: 0 }
      };

      function computeWaterCacheKey() {
        const at = (arrayTypeEl && arrayTypeEl.value === "roof") ? "roof" : "waves";
        const surf = (surfaceTypeEl && surfaceTypeEl.value) ? String(surfaceTypeEl.value).toLowerCase() : "";
        const az = clampAzimuth(parseInt((azimuthEl && azimuthEl.value) ? azimuthEl.value : "180", 10));
        const elev = parseFloat((elevationEl && elevationEl.value) ? elevationEl.value : "0.0");
        const lat = (currentLocation && Number.isFinite(Number(currentLocation.lat))) ? Number(currentLocation.lat) : 0;
        const ww = (typeof waterWidthM === "number" && Number.isFinite(waterWidthM)) ? waterWidthM : 0;

        let geom = {};
        if (at === "waves") {
          geom = { panelsPerRow: parseInt((wavesPanelsPerRowEl && wavesPanelsPerRowEl.value) ? wavesPanelsPerRowEl.value : "5", 10) };
        } else {
          geom = {
            cols: parseInt((roofColsEl && roofColsEl.value) ? roofColsEl.value : "20", 10),
            rows: parseInt((roofRowsEl && roofRowsEl.value) ? roofRowsEl.value : "4", 10),
            tilt: parseFloat((roofTiltEl && roofTiltEl.value) ? roofTiltEl.value : "15")
          };
        }

        // Keep key compact but stable.
        return JSON.stringify({ at, surf, az, elev, ww, latSign: (lat >= 0 ? 1 : -1), geom });
      }

      function invalidateWaterState(reason = "") {
        lastShadowMaskOwnerKey = null;
        lastShadowMaskOwnerType = null;
        lastShadowMaskPixels = null;
        lastShadowMaskW = 0;
        lastShadowMaskH = 0;
        // Keep per-type caches, but mark them stale.
        waterMaskStateByType.waves.key = null;
        waterMaskStateByType.roof.key = null;
      }

      function debugFrames(tag = "") {
        if (!window.THREE) return;
        if (!groundMesh || !arrayGroup) {
        console.log("[FRAMES]", tag, "missing groundMesh/arrayGroup", { groundMesh: !!groundMesh, arrayGroup: !!arrayGroup });
        return;
      }

      // Forward vector in local space (Z+)
      const fwd = new THREE.Vector3(0, 0, 1);

      const gQuat = groundMesh.getWorldQuaternion(new THREE.Quaternion());
      const aQuat = arrayGroup.getWorldQuaternion(new THREE.Quaternion());

      const gFwd = fwd.clone().applyQuaternion(gQuat);
      const aFwd = fwd.clone().applyQuaternion(aQuat);

      console.log("[FRAMES]", tag, {
        surface: surfaceTypeEl?.value,
        elev: elevationEl?.value,
        az: azimuthEl?.value,
        ground_rotY: groundMesh.rotation?.y,
        array_rotY: arrayGroup.rotation?.y,
        ground_fwd: { x: +gFwd.x.toFixed(3), y: +gFwd.y.toFixed(3), z: +gFwd.z.toFixed(3) },
        array_fwd: { x: +aFwd.x.toFixed(3), y: +aFwd.y.toFixed(3), z: +aFwd.z.toFixed(3) },
        groundDims: (typeof groundDims !== "undefined" ? groundDims : null)
      });
    }


let waterShadowMesh = null;
        function updateGroundShadowTextureFromMask(maskPixels, w, h) {
        if (currentRenderMode === 'textures') {
          // In textured mode we keep the ground/water material maps intact (no heatmap shadow map overlays).
          if (waterShadowMesh) waterShadowMesh.visible = false;
          return;
        }
        // The per-pixel shadow mask visualization can introduce a visible grid pattern
        // on large surfaces (ground/water) because it is a relatively low-resolution
        // DataTexture. For presentation-quality visuals we rely on the projected shadow
        // overlay (see updateProjectedShadow) and keep the mask only for export/audit.
        const SHOW_SURFACE_SHADOW_MASK_TEXTURE = false;
        if (!SHOW_SURFACE_SHADOW_MASK_TEXTURE) {
          if (waterShadowMesh) waterShadowMesh.visible = false;
          if (groundMesh && groundMesh.material && groundMesh.material.map) {
            groundMesh.material.map = null;
            groundMesh.material.needsUpdate = true;
          }
          return;
        }
        // maskPixels: Uint8Array of [0..255] "shadow strength" samples (0 = no shadow, 255 = full shadow)
        // For Ground: apply as grayscale map on the ground mesh (legacy behaviour).
        // For Water: apply as alphaMap on a dedicated overlay mesh so the shadow is one color and smooth.
        if (!maskPixels || !w || !h || !groundMesh) return;

        const isWater = (surfaceEl && String(surfaceEl.value).toLowerCase() === "water");
        const n = w * h;

        // Build RGBA buffer
        const rgba = new Uint8Array(n * 4);
        if (isWater) {
          // Black with varying alpha
          for (let i = 0; i < n; i++) {
            const a = maskPixels[i]; // 0..255
            const j = i * 4;
            rgba[j] = 0;
            rgba[j + 1] = 0;
            rgba[j + 2] = 0;
            rgba[j + 3] = a;
          }
        } else {
          // Grayscale as RGB (alpha opaque)
          for (let i = 0; i < n; i++) {
            const v = maskPixels[i];
            const j = i * 4;
            rgba[j] = v;
            rgba[j + 1] = v;
            rgba[j + 2] = v;
            rgba[j + 3] = 255;
          }
        }

        if (isWater) {
          if (!waterShadowMesh) return;
          if (!waterShadowTexture || waterShadowTexture.image.width !== w || waterShadowTexture.image.height !== h) {
            waterShadowTexture = new THREE.DataTexture(rgba, w, h, THREE.RGBAFormat);
            waterShadowTexture.needsUpdate = true;
            waterShadowTexture.flipY = false;
            waterShadowTexture.generateMipmaps = false;
            waterShadowTexture.minFilter = THREE.LinearFilter;
            waterShadowTexture.magFilter = THREE.LinearFilter;
            // Ensure overlay mesh uses alphaMap
            const mat = waterShadowMesh.material;
            mat.alphaMap = waterShadowTexture;
            mat.needsUpdate = true;
          } else {
            waterShadowTexture.image.data = rgba;
            waterShadowTexture.needsUpdate = true;
          }
          waterShadowMesh.visible = true;
          // Keep overlay aligned with ground mesh
          waterShadowMesh.position.copy(groundMesh.position);
          waterShadowMesh.rotation.copy(groundMesh.rotation);
          waterShadowMesh.scale.copy(groundMesh.scale);
          // Tiny offset to avoid z-fighting
          waterShadowMesh.position.y += 0.003;
          // Do not set a map on the water surface itself (prevents banded coloration)
          groundMesh.material.map = null;
          groundMesh.material.needsUpdate = true;
        } else {
          // Ground case
          if (waterShadowMesh) waterShadowMesh.visible = false;
          if (!groundShadowTexture || groundShadowTexture.image.width !== w || groundShadowTexture.image.height !== h) {
            groundShadowTexture = new THREE.DataTexture(rgba, w, h, THREE.RGBAFormat);
            groundShadowTexture.needsUpdate = true;
            groundShadowTexture.flipY = false;
            groundShadowTexture.generateMipmaps = false;
            groundShadowTexture.minFilter = THREE.LinearFilter;
            groundShadowTexture.magFilter = THREE.LinearFilter;
            groundMesh.material.map = groundShadowTexture;
            groundMesh.material.needsUpdate = true;
          } else {
            groundShadowTexture.image.data = rgba;
            groundShadowTexture.needsUpdate = true;
          }
        }
      }

      function applyPerPanelShadowGradient() {
        if (currentRenderMode === 'textures') return;
        // Works in BOTH modes:
        // - Snapshot: base POA comes from the snapshot daily_mean_poa_w_m2 per orientation.
        // - Realtime: base POA is a fast incidence proxy per panel.
        if (!lastShadowMaskPixels || !lastShadowMaskW || !lastShadowMaskH) return;
        if (!groundMesh) return;
        if (!panelMeshes || panelMeshes.length === 0) return;

        // Water mode: only apply a shadow mask that matches the current geometry "key".
        // This prevents cross-contamination (e.g. roof picking up waves mask) and stale sampling.
        const _surf = (surfaceTypeEl && surfaceTypeEl.value) ? String(surfaceTypeEl.value).toLowerCase() : "";
        if (_surf === "water") {
          const _key = computeWaterCacheKey();
          if (!lastShadowMaskOwnerKey || lastShadowMaskOwnerKey !== _key) return;
        }


        const w = lastShadowMaskW, h = lastShadowMaskH;
        const pixels = lastShadowMaskPixels;

        // Sun direction (from surface toward sun) for proxy POA when not in snapshot mode.
        let sunRay = null;
        if (!useSnapshotColors && sunLight) {
          const sunDir = new THREE.Vector3().subVectors(sunLight.target.position, sunLight.position).normalize();
          sunRay = sunDir.clone().negate();
        }

        // In snapshot mode, preserve the snapshot colour mapping (min/max) and only
        // apply the GPU-derived shadow (tau) as an intensity modulation.
        // Otherwise the palette will "jump" after the water mask is computed.
        const values = [];
        const baseValues = [];
        const q = new THREE.Quaternion();
        const nLocal = new THREE.Vector3(0, 1, 0);
        const nWorld = new THREE.Vector3();
        const world = new THREE.Vector3();

        for (const p of panelMeshes) {
          // Determine base POA
          let base = null;
          let beamPart = null;
          let diffusePart = 0;
          let groundRefPart = 0;
          if (useSnapshotColors && orientationSnapshotMap && orientationSnapshotMap.size) {
            const key = p?.userData?.orientationKey;
            const o = key ? orientationSnapshotMap.get(key) : null;
            if (o && Number.isFinite(o.daily_mean_poa_w_m2)) base = Number(o.daily_mean_poa_w_m2);
                    } else if (sunRay) {
            // Real-time: use hourly irradiance (DNI/DHI/GHI) when available.
            // Apply tau to BEAM only; diffuse + ground-reflected are left unshadowed.
            p.getWorldQuaternion(q);
            nWorld.copy(nLocal).applyQuaternion(q).normalize();
            // Solar Waves panels can be constructed with reversed winding/normal for one half of the fold.
            // Enforce an upward-facing normal to keep sun-facing side mapped to higher POA.
            if ((arrayTypeEl && arrayTypeEl.value === "waves") && nWorld.y < 0) nWorld.multiplyScalar(-1);


            ensureRealtimeMeteo();
            const irr = getIrradianceAtUTC(new Date());
            const surfaceType = (surfaceEl && surfaceEl.value) ? surfaceEl.value : "";

            if (irr && Number.isFinite(Number(irr.dni)) && Number.isFinite(Number(irr.dhi)) && Number.isFinite(Number(irr.ghi))) {
              const dni = Number(irr.dni), dhi = Number(irr.dhi), ghi = Number(irr.ghi);
              const cosInc = Math.max(0, nWorld.dot(sunRay));
              const cosTilt = THREE.MathUtils.clamp(nWorld.y, -1, 1);
              const albedo = (String(surfaceType).toLowerCase() === "water") ? 0.06 : 0.20;

              beamPart = dni * cosInc;
              diffusePart = dhi * (1 + cosTilt) * 0.5;
              groundRefPart = ghi * albedo * (1 - cosTilt) * 0.5;
              base = Math.max(0, beamPart + diffusePart + groundRefPart);
            } else {
              // Fallback proxy: diffuse + beam*cos(incidence)
              const cosInc = Math.max(0, nWorld.dot(sunRay));
              const diffuseProxy = 200;        // W/m² baseline
              const beamProxy = 800 * cosInc;  // W/m² scaled by incidence
              beamPart = beamProxy;
              diffusePart = diffuseProxy;
              groundRefPart = 0;
              base = diffuseProxy + beamProxy;
            }
          }

          if (base == null || !Number.isFinite(base)) { values.push(null); baseValues.push(null); continue; }
          baseValues.push(base);

          // Sample tau from the GPU shadow mask at the panel's footprint position on the ground plane.
          p.getWorldPosition(world);
          const local = groundMesh.worldToLocal(world.clone());
          const sx = (groundDims && Number.isFinite(groundDims.sx)) ? groundDims.sx : groundSize;
          const sz = (groundDims && Number.isFinite(groundDims.sz)) ? groundDims.sz : groundSize;
          const u = (local.x / sx) + 0.5;
          const v = (local.z / sz) + 0.5;
          if (!(u >= 0 && u <= 1 && v >= 0 && v <= 1)) { values.push(base); continue; }

          const xi = Math.max(0, Math.min(w - 1, Math.floor(u * (w - 1))));
          const yi = Math.max(0, Math.min(h - 1, Math.floor((1 - v) * (h - 1))));
          const idx = (yi * w + xi) * 4;
          const mask = pixels.length === w * h * 4 ? pixels[idx] : pixels[yi * w + xi];
          const tau = (mask / 255.0);

          const adj = (beamPart != null ? (beamPart * tau + diffusePart + groundRefPart) : (base * tau));
          values.push(adj);
          p.userData.poa_eff_w_m2 = adj;
          p.userData.tau_beam = tau;
        }

        const mm = computeRobustMinMax(values, 0, 1000);
        let vmin = mm.min;
        let vmax = mm.max;

        // Snapshot mode: keep the same scale as the snapshot base mapping.
        if (useSnapshotColors && snapshotLegendMinMax && Number.isFinite(snapshotLegendMinMax.min) && Number.isFinite(snapshotLegendMinMax.max)) {
          vmin = snapshotLegendMinMax.min;
          vmax = snapshotLegendMinMax.max;
        }

// Keep legend coherent
        if (!useSnapshotColors || !snapshotLegendMinMax) {
          currentLegendMode = 'realtime';
          updateLegendUI({
            min: vmin,
            max: vmax,
            meanText: legendMeanEl ? legendMeanEl.textContent : null,
            noteText: 'Higher colour = higher POA (W/m²)'
          });
        }

        for (let i = 0; i < panelMeshes.length; i++) {
          const p = panelMeshes[i];
          const valAdj = values[i];
          const valBase = baseValues[i];
          if (!Number.isFinite(valAdj) || !Number.isFinite(valBase)) continue;

          // Snapshot: map by base POA and dim/brighten by tau-derived modulation.
          // Real-time: map by the adjusted value.
          const tau = (p && p.userData && Number.isFinite(p.userData.tau_beam)) ? p.userData.tau_beam : 1.0;

// Snapshot mode: keep hue mapping locked to the snapshot base POA (valBase) using snapshotLegendMinMax.
// Apply water shading as intensity modulation only (do NOT scale the value into the colormap), to avoid
// collapsing everything below vmin when tau is small.
const intensityMod = (useSnapshotColors && snapshotLegendMinMax) ? (0.35 + 0.65 * tau) : 1.0;
const valForColor = (useSnapshotColors && snapshotLegendMinMax) ? valBase : valAdj;

const color = scalarToColor(valForColor, vmin, vmax);

          // Apply to all meshes under this panel instance.
          p.traverse(child => {
            if (child && child.isMesh && child.material) {
              if (!child.userData._hasUniqueMat) {
                child.material = child.material.clone();
                child.userData._hasUniqueMat = true;
              }
              if (child.material.color) child.material.color.set(0x000000);
              if (child.material.emissive) {
                child.material.emissive.copy(color);
                child.material.emissiveIntensity = intensityMod;
              }
              child.material.metalness = 0.0;
              child.material.roughness = 1.0;
              child.material.needsUpdate = true;
            }
          });
        }
      }

      let wavesGroup, roofGroup;
      let groundTilingGroup; // clones for ground array-of-arrays
      const ARRAY_TILE_SPACING_M = 1.25;

      // ============================================================
      // DEBUG: Ground tiling (array-of-arrays)
      // ============================================================
      const DEBUG_TILING = true; // set false to silence tiling logs

      const __tilingDebug = { last: null };
      function dbgTiling(msg, obj) {
        if (!DEBUG_TILING) return;
        try {
          const payload = (obj === undefined) ? null : obj;
          console.log("%c[TILING] " + msg, "color:#2b7a0b;font-weight:600;", payload);
          __tilingDebug.last = { ts: Date.now(), msg, obj: payload };
          window.__SW_LAST_TILING = __tilingDebug.last;
        } catch (e) {
          // never break the app due to debugging
        }
      }

      // Surface any unexpected errors in a consistent place (helps when browser extensions spam the console).
      window.addEventListener("error", (ev) => {
        try {
          const m = (ev && ev.message) ? ev.message : "Unknown error";
          console.warn("[SW] window.error:", m);
          if (resultsStatusEl) resultsStatusEl.textContent = "JS error: " + m;
        } catch (e) {}
      });
      window.addEventListener("unhandledrejection", (ev) => {
        try {
          const m = (ev && ev.reason && (ev.reason.message || String(ev.reason))) ? (ev.reason.message || String(ev.reason)) : "Unhandled promise rejection";
          console.warn("[SW] unhandledrejection:", m);
          if (resultsStatusEl) resultsStatusEl.textContent = "JS promise rejection: " + m;
        } catch (e) {}
      });

      let shadowProjectionGroup;
      let projectedShadowMaterial;
      let contourGroup;
      let currentPanelDims = { w: 1.0, h: 1.6 };
      const ENABLE_TOOLTIPS = false; // disable all hover tooltips (panel/ground snapshots)
      let snapshotData = null;
      let snapshotSunLock = null;
      let useSnapshotColors = false;
      let snapshotLegendMinMax = null; // {min,max}
      let currentLegendMode = 'annual'; // 'annual'|'snapshot'|'realtime'

      // Rendering mode: 'textures' for realistic materials, 'heatmap' for the existing emissive snapshot/realtime coloring.
      let currentRenderMode = 'textures';

      // Keep original (heatmap) materials so we can restore them after switching modes.
      let _heatmapGroundMaterial = null;

      // Realistic texture assets (procedural canvas textures to keep the app self-contained)
      let _texPV = null;
      let _texGround = null;
      let _texWater = null;
      let _texWaterNormal = null;

      // Materials for textured mode
      let _matPVTop = null;
      let _matPVBottom = null;
      let _matPVFrame = null;
      let _matGroundTextured = null;
      let _matWaterTextured = null;

      // Async init guards / caches for external PBR + HDR IBL assets
      let _pbrInitPromise = null;
      let _envInitPromise = null;
      let _envMapTex = null;
      let _pmremGen = null;

      function _makeCanvasTexture(w, h, painterFn) {
        const c = document.createElement('canvas');
        c.width = w; c.height = h;
        const ctx = c.getContext('2d');
        painterFn(ctx, w, h);
        const tex = new THREE.CanvasTexture(c);
        tex.wrapS = THREE.RepeatWrapping;
        tex.wrapT = THREE.RepeatWrapping;
        tex.anisotropy = 8;
        tex.needsUpdate = true;
        return tex;
      }

      function _makePVTexture() {
        // Simple "PV cell" look: blue gradient + grid lines + subtle noise.
        return _makeCanvasTexture(512, 512, (ctx, w, h) => {
          const g = ctx.createLinearGradient(0, 0, 0, h);
          g.addColorStop(0, '#143a6b');
          g.addColorStop(0.5, '#0d2f5f');
          g.addColorStop(1, '#081f3f');
          ctx.fillStyle = g;
          ctx.fillRect(0, 0, w, h);

          // cells
          const cols = 12, rows = 12;
          const cw = w / cols, ch = h / rows;

          ctx.lineWidth = 2;
          ctx.strokeStyle = 'rgba(30, 80, 140, 0.85)';
          for (let i = 0; i <= cols; i++) {
            const x = Math.round(i * cw) + 0.5;
            ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke();
          }
          for (let j = 0; j <= rows; j++) {
            const y = Math.round(j * ch) + 0.5;
            ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(w, y); ctx.stroke();
          }

          // busbars
          ctx.lineWidth = 4;
          ctx.strokeStyle = 'rgba(200, 220, 255, 0.25)';
          for (let i = 0; i < 3; i++) {
            const x = (i + 1) * w / 4;
            ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x, h); ctx.stroke();
          }

          // subtle noise
          const img = ctx.getImageData(0, 0, w, h);
          const d = img.data;
          for (let i = 0; i < d.length; i += 4) {
            const n = (Math.random() - 0.5) * 14;
            d[i] = Math.max(0, Math.min(255, d[i] + n));
            d[i+1] = Math.max(0, Math.min(255, d[i+1] + n));
            d[i+2] = Math.max(0, Math.min(255, d[i+2] + n));
          }
          ctx.putImageData(img, 0, 0);
        });
      }

      function _makeGroundTexture() {
        // Low-frequency green/brown noise to read like grass/soil at distance.
        return _makeCanvasTexture(512, 512, (ctx, w, h) => {
          ctx.fillStyle = '#5f7f59';
          ctx.fillRect(0, 0, w, h);

          const img = ctx.getImageData(0, 0, w, h);
          const d = img.data;

          // multi-scale noise
          for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
              const i = (y * w + x) * 4;
              const n1 = (Math.random() - 0.5) * 40;
              const n2 = (Math.random() - 0.5) * 18;
              const g = 95 + n1;
              const r = 80 + n2;
              const b = 70 + n2;
              d[i] = Math.max(0, Math.min(255, r));
              d[i+1] = Math.max(0, Math.min(255, g));
              d[i+2] = Math.max(0, Math.min(255, b));
              d[i+3] = 255;
            }
          }
          ctx.putImageData(img, 0, 0);

          // faint "mow" lines
          ctx.globalAlpha = 0.10;
          ctx.fillStyle = '#ffffff';
          for (let y = 0; y < h; y += 24) {
            ctx.fillRect(0, y, w, 8);
          }
          ctx.globalAlpha = 1.0;
        });
      }

      function _makeWaterTextures() {
        // Pond/canal feel: greenish base with darker swirls and a matching normal map.
        const colorTex = _makeCanvasTexture(512, 512, (ctx, w, h) => {
          const g = ctx.createLinearGradient(0, 0, w, h);
          g.addColorStop(0, '#2e6f68');
          g.addColorStop(0.5, '#2a7b66');
          g.addColorStop(1, '#1f5e57');
          ctx.fillStyle = g;
          ctx.fillRect(0, 0, w, h);

          // swirls
          ctx.globalAlpha = 0.25;
          for (let k = 0; k < 1400; k++) {
            const x = Math.random() * w;
            const y = Math.random() * h;
            const r = 10 + Math.random() * 60;
            ctx.beginPath();
            ctx.arc(x, y, r, 0, Math.PI * 2);
            ctx.fillStyle = Math.random() < 0.5 ? 'rgba(10,30,25,0.35)' : 'rgba(120,180,155,0.25)';
            ctx.fill();
          }
          ctx.globalAlpha = 1.0;

          // subtle highlight streaks
          ctx.globalAlpha = 0.12;
          ctx.strokeStyle = 'rgba(255,255,255,0.45)';
          ctx.lineWidth = 2;
          for (let i = 0; i < 60; i++) {
            const y = Math.random() * h;
            ctx.beginPath();
            ctx.moveTo(0, y);
            ctx.bezierCurveTo(w*0.25, y + (Math.random()-0.5)*30, w*0.75, y + (Math.random()-0.5)*30, w, y);
            ctx.stroke();
          }
          ctx.globalAlpha = 1.0;
        });

        // Normal map: generate a height field then convert to normals.
        const normalTex = _makeCanvasTexture(512, 512, (ctx, w, h) => {
          const img = ctx.createImageData(w, h);
          const d = img.data;

          // height field
          const height = new Float32Array(w * h);
          for (let i = 0; i < height.length; i++) height[i] = 0;

          // add ripples
          const ripples = 90;
          for (let r = 0; r < ripples; r++) {
            const cx = Math.random() * w;
            const cy = Math.random() * h;
            const amp = 0.6 + Math.random() * 0.8;
            const freq = 0.03 + Math.random() * 0.08;
            for (let y = 0; y < h; y++) {
              for (let x = 0; x < w; x++) {
                const dx = x - cx, dy = y - cy;
                const dist = Math.sqrt(dx*dx + dy*dy);
                height[y*w + x] += amp * Math.sin(dist * freq) * Math.exp(-dist * 0.01);
              }
            }
          }

          // normalize + compute normals
          const scale = 3.0;
          for (let y = 0; y < h; y++) {
            for (let x = 0; x < w; x++) {
              const i = y*w + x;
              const hl = height[y*w + Math.max(0, x-1)];
              const hr = height[y*w + Math.min(w-1, x+1)];
              const hu = height[Math.max(0, y-1)*w + x];
              const hd = height[Math.min(h-1, y+1)*w + x];
              const dx = (hr - hl) * scale;
              const dy = (hd - hu) * scale;
              // normal = normalize([-dx, -dy, 1])
              let nx = -dx, ny = -dy, nz = 1.0;
              const inv = 1.0 / Math.sqrt(nx*nx + ny*ny + nz*nz);
              nx *= inv; ny *= inv; nz *= inv;

              const o = i * 4;
              d[o]   = Math.round((nx * 0.5 + 0.5) * 255);
              d[o+1] = Math.round((ny * 0.5 + 0.5) * 255);
              d[o+2] = Math.round((nz * 0.5 + 0.5) * 255);
              d[o+3] = 255;
            }
          }
          ctx.putImageData(img, 0, 0);
        });

        return { colorTex, normalTex };
      }

      function initRealisticMaterialsIfNeeded() {
        if (!__firstVisualReady) setLoadingStatus("Loading textures…");
        // Loads external PBR texture sets once and builds materials.
        // This keeps rendering self-consistent and allows IBL (HDR) lighting to do most of the work.
        if (_matPVTop && _matGroundTextured && _matWaterTextured) return Promise.resolve();

        if (_pbrInitPromise) return _pbrInitPromise;

        const TL = new THREE.TextureLoader(_loadingManager);

        function loadTex(url, opts) {
          opts = opts || {};
          return new Promise((resolve, reject) => {
            TL.load(
              url,
              (tex) => {
                tex.wrapS = THREE.RepeatWrapping;
                tex.wrapT = THREE.RepeatWrapping;
                if (opts.srgb && ('encoding' in tex)) tex.encoding = THREE.sRGBEncoding;
                // (r140) three uses .encoding; newer versions use .colorSpace
                resolve(tex);
              },
              undefined,
              (err) => reject(err || new Error('Failed to load texture: ' + url))
            );
          });
        }

        async function loadTexOptional(url, opts) {
          try {
            return await loadTex(url, opts);
          } catch (err) {
            console.warn('[PBR] Optional texture missing:', url, err);
            return null;
          }
        }
  

        // Try multiple URLs, return the first successfully loaded texture.
        async function loadTexFirst(urls, opts = {}) {
          let lastErr = null;
          for (const url of urls) {
            try {
              return await loadTex(url, opts);
            } catch (err) {
              lastErr = err;
            }
          }
          throw lastErr || new Error('No URLs provided to loadTexFirst');
        }


        // Asset paths (placeholders) – see folder list in README section below.
        const ASSETS = {
          pv: {
            albedo: 'assets/pbr/pv/pv_albedo.jpg',
            normal: 'assets/pbr/pv/pv_normal.jpg',
            roughness: 'assets/pbr/pv/pv_roughness.jpg'
          },
          ground: {
            albedo: 'assets/pbr/ground/ground_albedo.jpg',
            normal: 'assets/pbr/ground/ground_normal.jpg',
            roughness: 'assets/pbr/ground/ground_roughness.jpg'
          },
          water: {
            albedo: 'assets/pbr/water/water_albedo.jpg',
            normal: 'assets/pbr/water/water_normal.jpg',
            roughness: 'assets/pbr/water/water_roughness.jpg' // optional; if missing we fall back to constant roughness
          }
        };

        
        // --- helper: try multiple optional URLs (local fallback; avoids scope issues) ---
        const loadTexOptionalFirst = async (urls, opts = {}) => {
          for (const url of urls) {
            if (!url) continue;
            const tex = await loadTexOptional(url, opts);
            if (tex) return tex;
          }
          return null;
        };
_pbrInitPromise = (async () => {
          // Ensure procedural PV texture exists as fallback even if PBR textures are missing
          if (!_texPV) {
            _texPV = _makePVTexture();
            _texPV.wrapS = _texPV.wrapT = THREE.ClampToEdgeWrapping;
            _texPV.center.set(0.5, 0.5);
            _texPV.rotation = Math.PI / 2;
            _texPV.repeat.set(1, 1);
            _texPV.needsUpdate = true;
          }

          // PV
          const pvA = await loadTexOptionalFirst([
            ASSETS.pv.albedo,
            'assets/textures/pv/pv_albedo.jpg',
            'assets/textures/pv/pv_albedo.png'
          ], { srgb: true });
          const pvN = await loadTexOptionalFirst([
            ASSETS.pv.normal,
            'assets/textures/pv/pv_normal.jpg',
            'assets/textures/pv/pv_normal.png'
          ]);
          const pvR = await loadTexOptionalFirst([
            ASSETS.pv.roughness,
            'assets/textures/pv/pv_roughness.jpg',
            'assets/textures/pv/pv_roughness.png'
          ]);
          // PV texture transform: rotate 90° and stretch (no tiling)
          if (pvA) {
            pvA.wrapS = pvA.wrapT = THREE.ClampToEdgeWrapping;
            pvA.center.set(0.5, 0.5);
            pvA.rotation = 0;
            pvA.repeat.set(1, 1);
          }
          if (pvN) {
            pvN.wrapS = pvN.wrapT = THREE.ClampToEdgeWrapping;
            pvN.center.set(0.5, 0.5);
            pvN.rotation = 0;
            pvN.repeat.set(1, 1);
          }
          if (pvR) {
            pvR.wrapS = pvR.wrapT = THREE.ClampToEdgeWrapping;
            pvR.center.set(0.5, 0.5);
            pvR.rotation = 0;
            pvR.repeat.set(1, 1);
          }
// Ground
          const gA = await loadTex(ASSETS.ground.albedo, { srgb: true });
          const gN = await loadTexOptional(ASSETS.ground.normal);
          const gR = await loadTexOptional(ASSETS.ground.roughness);
          gA.repeat.set(10, 10);
          if (gN) gN.repeat.set(10, 10);
          if (gR) gR.repeat.set(10, 10);
// Water (albedo optional; normal optional; roughness optional)
          const wA = await loadTexOptionalFirst([
            ASSETS.water.albedo,
            'assets/pbr/water/water_albedo.jpg',
            'assets/pbr/water/water_albedo.png'
          ], { srgb: true });
          if (wA) wA.repeat.set(6, 6);
          const wN = await loadTexOptionalFirst([
            ASSETS.water.normal,
            'assets/pbr/water/water_normal.jpg',
            'assets/pbr/water/water_normal.png'
          ]);
          if (wN) { wN.wrapS = wN.wrapT = THREE.RepeatWrapping; wN.repeat.set(0.5, 0.5); }
          let wR = null;
          try {
            wR = await loadTex(ASSETS.water.roughness);
            wR.repeat.set(6, 6);
          } catch (e) {
            wR = null;
          }

          _matPVTop = new THREE.MeshPhysicalMaterial({
            // PV "glass" feel: strong specular reflections under HDR IBL
            map: (pvA || _texPV || null),
            normalMap: pvN,
            roughnessMap: pvR,

            // Tune these for stronger reflections:
            roughness: 0.25,
            metalness: 0.5,
            ior: 1.5,
            reflectivity: 0.75,
            specularIntensity: 1.2,

            clearcoat: 1.0,
            clearcoatRoughness: 0.04,

            envMapIntensity: 3.5
          });

          _matPVBottom = new THREE.MeshStandardMaterial({
            color: 0xffffff,
            roughness: 0.85,
            metalness: 0.0
          });

          _matPVFrame = new THREE.MeshStandardMaterial({
            color: 0x111111,
            roughness: 0.6,
            metalness: 0.1
          });

          _matGroundTextured = new THREE.MeshStandardMaterial({
            map: gA,
            roughnessMap: gR,
            roughness: 1.0,
            metalness: 0.0
          });
          if (gN) {
            _matGroundTextured.normalMap = gN;
            _matGroundTextured.normalScale = new THREE.Vector2(0.6, 0.6);
            _matGroundTextured.needsUpdate = true;
          }

// Use MeshPhysicalMaterial for water for better specular/clearcoat with HDR IBL.
          _matWaterTextured = new THREE.MeshPhysicalMaterial({
            // Water appearance tuning:
            // - color: base tint under the albedo map (if present); adjust for "more green" / "more blue"
            color: 0x020611, // green-blue canal/pond tint
            roughness: 0.02,
            metalness: 0.3,
            reflectivity: 1.0,
            ior: 1.33,
            specularIntensity: 1.35,
            clearcoat: 1.0,
            clearcoatRoughness: 0.01,
            envMapIntensity: 6.8,
            transparent: true,
            opacity: 0.98
          });

          if (wA) {
            _matWaterTextured.map = wA;
            _matWaterTextured.needsUpdate = true;
          }
          if (wN) {
            _matWaterTextured.normalMap = wN;
            _matWaterTextured.normalScale = new THREE.Vector2(2.0, 2.0);
            _matWaterTextured.needsUpdate = true;
          }

if (wR) {
            _matWaterTextured.roughnessMap = wR;
            _matWaterTextured.needsUpdate = true;
          }

          return true;
        })().catch((err) => {
          console.warn('[PBR] Failed to init PBR materials; falling back to procedural textures.', err);
          // If PBR fails, fall back to the procedural generator pipeline already in the file.
          _pbrInitPromise = null;
          _texPV = _makePVTexture();
          // PV texture transform: rotate 90° and force 1×1 mapping (no tiling)
          _texPV.wrapS = _texPV.wrapT = THREE.ClampToEdgeWrapping;
          _texPV.center.set(0.5, 0.5);
          _texPV.rotation = Math.PI / 2;
          _texPV.repeat.set(1, 1);
          _texPV.needsUpdate = true;

          _texGround = _makeGroundTexture();
          _texGround.repeat.set(6, 6);

          const wt = _makeWaterTextures();
          _texWater = wt.colorTex;
          _texWater.repeat.set(4, 4);
          _texWaterNormal = wt.normalTex;
          _texWaterNormal.repeat.set(0.75, 0.75);

          _matPVTop = new THREE.MeshStandardMaterial({ map: _texPV, roughness: 0.65, metalness: 0.25 });
          _matPVBottom = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.92, metalness: 0.0 });
          _matPVFrame = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.78, metalness: 0.05 });

          _matGroundTextured = new THREE.MeshStandardMaterial({ map: _texGround, roughness: 0.95, metalness: 0.0 });
          _matWaterTextured = new THREE.MeshStandardMaterial({
            map: _texWater,
            normalMap: _texWaterNormal,
            roughness: 0.25,
            metalness: 0.0,
            transparent: true,
            opacity: 0.98
          });
          return true;
        });

        return _pbrInitPromise;
      }

      async function enableTextureLightingIfNeeded() {
        if (!__firstVisualReady) setLoadingStatus("Finalizing lighting…");
        // HDR IBL for PBR mode. Background remains unchanged; only scene.environment is set.
        if (!renderer || !scene) return;
        if (scene.environment && _envMapTex) return;

        if (_envInitPromise) return _envInitPromise;

        const HDR_URL = 'assets/hdr/studio_small_09_1k.hdr'; // placeholder
        _envInitPromise = new Promise((resolve, reject) => {
          try {
            if (!_pmremGen) _pmremGen = new THREE.PMREMGenerator(renderer);
            _pmremGen.compileEquirectangularShader();

            const loader = new THREE.RGBELoader(_loadingManager);
            loader.load(
              HDR_URL,
              (hdrTex) => {
                const pmrem = _pmremGen.fromEquirectangular(hdrTex);
                hdrTex.dispose();
                _envMapTex = pmrem.texture;
                scene.environment = _envMapTex;
                resolve(true);
              },
              undefined,
              (err) => {
                console.warn('[HDR] Failed to load HDR environment map:', err);
                // Soft-fail: keep environment null so the app still runs.
                _envMapTex = null;
                scene.environment = null;
                resolve(false);
              }
            );
          } catch (e) {
            console.warn('[HDR] Exception while initializing HDR IBL:', e);
            _envMapTex = null;
            scene.environment = null;
            resolve(false);
          }
        });

        return _envInitPromise;
      }

      function disableTextureLighting() {
        if (!scene) return;
        // Preserve background color; only remove IBL environment.
        scene.environment = null;
      }

      function applyRenderModeToGround() {
        if (!groundMesh) return;
        const surf = (surfaceTypeEl && surfaceTypeEl.value) ? String(surfaceTypeEl.value).toLowerCase() : 'ground';

        if (!_heatmapGroundMaterial) _heatmapGroundMaterial = groundMesh.material;

        if (currentRenderMode === 'textures') {
          // Ensure PBR/procedural texture materials are ready before assignment (prevents race where panels/water stay white/fallback).
          initRealisticMaterialsIfNeeded().then(() => {
            const mat = (surf === 'water') ? _matWaterTextured : _matGroundTextured;
            if (mat) {
              groundMesh.material = mat;
              groundMesh.material.needsUpdate = true;
            }
            // Ensure any overlay shadows are hidden (heatmap-only visualization)
            if (waterShadowMesh) waterShadowMesh.visible = false;
            if (shadowOverlayMesh) shadowOverlayMesh.visible = false;
          }).catch(() => {
            // If init fails, we keep whatever material is currently assigned.
          });
          return;
        }

        // Heatmap mode: restore original material + base colors.
        if (_heatmapGroundMaterial) {
          groundMesh.material = _heatmapGroundMaterial;
          const isWater = surf === 'water';
          if (groundMesh.material && groundMesh.material.color) {
            groundMesh.material.color.setHex(isWater ? 0x3aa3ff : 0xc3f4f6);
          }
          groundMesh.material.map = null;
          groundMesh.material.needsUpdate = true;
        }
      }

      function applyRenderModeToPanels() {
        if (!panelMeshes || !panelMeshes.length) return;

        if (currentRenderMode === 'textures') {
          // Ensure PBR/procedural texture materials are ready before assignment (prevents race where panels stay white).
          initRealisticMaterialsIfNeeded().then(() => {
            panelMeshes.forEach(p => {
              if (!p || !p.isMesh) return;
              // BoxGeometry material order: [right, left, top, bottom, front, back] == [+X, -X, +Y, -Y, +Z, -Z]
              const mats = [_matPVFrame, _matPVFrame, _matPVTop, _matPVBottom, _matPVFrame, _matPVFrame];
              if (mats.every(m => !!m)) {
                p.material = mats;
                if (Array.isArray(p.material)) p.material.forEach(mm => { if (mm) mm.needsUpdate = true; });
              }
              // Remove emissive overrides that heatmap mode uses
              if (p.material && Array.isArray(p.material)) {
                p.material.forEach(m => {
                  if (!m) return;
                  if (m.emissive) m.emissive.set(0x000000);
                  if (m.emissiveIntensity != null) m.emissiveIntensity = 0.0;
                });
              }
            });
          }).catch(() => {
            // If init fails, we keep existing materials.
          });
          return;
        }

        // Heatmap mode: restore per-panel unique MeshStandardMaterial so emissive coloring works.
        panelMeshes.forEach(p => {
          if (!p || !p.isMesh) return;
          if (Array.isArray(p.material)) {
            // Restore a single material instance
            const m = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.55, metalness: 0.05 });
            m.side = THREE.DoubleSide;
            p.material = m;
            p.userData.__uniqueMaterial = true;
          }
        });
      }

      function applyRenderModeToScene() {
        if (currentRenderMode === 'textures') {
          // Ensure HDR IBL + PBR materials are ready, then apply.
          Promise.all([
            enableTextureLightingIfNeeded(),
            initRealisticMaterialsIfNeeded()
          ]).then(() => {
            applyRenderModeToGround();
            applyRenderModeToPanels();
            // First clean render can be revealed once materials + IBL are applied.
            if (!__firstVisualReady) markFirstVisualReady();
          });
        } else {
          // Heatmap mode: remove IBL so heatmap readability remains stable/predictable.
          disableTextureLighting();
          applyRenderModeToGround();
          applyRenderModeToPanels();
        }
      }

      let pointer = new THREE.Vector2();
      let raycaster = new THREE.Raycaster();
      let pointerClientPos = { x: 0, y: 0 };
      let tooltipEl = null;
      function ensureTooltip() {
        // Tooltips are disabled by design for production embeds (Squarespace) and to avoid UI obstruction.
        if (!ENABLE_TOOLTIPS) {
          const existing = document.getElementById("snapshotTooltip");
          if (existing) existing.remove();
          tooltipEl = null;
          return;
        }
        if (!tooltipEl) {
          tooltipEl = document.createElement("div");
          tooltipEl.id = "snapshotTooltip";
          document.body.appendChild(tooltipEl);
        }
      }
      let orientationSnapshotMap = new Map();
      let snapshotColorRange = { min: 0, max: 0 };

      function degToRad(d) { return (d * Math.PI) / 180.0; }
      // State
      let panelsMeta = [];
      let currentLocation = null;
      let currentProvider = null;
      let pendingLocationResults = [];
      let geocodeInFlight = false;
      let lastGeocodeQuery = "";
      let geocodeRequestId = 0;
      let simTimeout = null;
      let isSimRunning = false;
      let lastSimMeanPOA = null;

      
      // Results integrity tracking
      let simIntentId = 0;
      let simPendingId = 0;
      let simCompletedId = 0;
      let simRenderedId = 0;
      ensureTooltip();

      function clampAzimuth(deg) {
        let d = Number.isFinite(deg) ? deg : 180;
        while (d < 0) d += 360;
        while (d >= 360) d -= 360;
        return d;
      }

      function azimuthForBackend(uiAzDeg, arrayType) {
        // UI convention: 0=N, 90=E, 180=S, 270=W
        // Backend sim_core._normalize_azimuth_deg() already converts UI->OpenMeteo convention.
        // Therefore: NEVER apply an extra 180° for roof/canopy.
        return clampAzimuth(Number(uiAzDeg));
      }

      function orientationKeyFromAzTilt(azDeg, tiltDeg) {
        const az = ((Number(azDeg) % 360) + 360) % 360;
        const azRounded = Math.round(az * 10) / 10;
        const tiltRounded = Math.round(Number(tiltDeg) * 10) / 10;
        return azRounded.toFixed(1) + "|" + tiltRounded.toFixed(1);
      }

      function lastFullYear() {
        return new Date().getFullYear() - 1;
      }

      
function approxSolarNoonUtcHourFromLon(lonDeg) {
  // Approximate solar noon in UTC hours from longitude.
  // Local solar noon ≈ 12:00 local solar time; UTC ≈ 12 - lon/15
  const lon = Number(lonDeg);
  if (!Number.isFinite(lon)) return 12;
  let h = 12 - (lon / 15.0);
  h = ((h % 24) + 24) % 24;
  return Math.max(0, Math.min(23, Math.round(h)));
}

function daysInMonthUTC(year, month1to12) {
        // month1to12: 1..12
        return new Date(Date.UTC(year, month1to12, 0)).getUTCDate();
      }

      function isoUtcNoZ(year, month1to12, day, hour) {
        const mm = String(month1to12).padStart(2, "0");
        const dd = String(day).padStart(2, "0");
        const hh = String(hour).padStart(2, "0");
        return `${year}-${mm}-${dd}T${hh}:00`;
      }

      // Optional: small yield to keep UI responsive during sampling
      function nextFrame() {
        return new Promise(resolve => requestAnimationFrame(() => resolve()));
      }

      function handlePointerMove(ev) {
        if (!renderer || !renderer.domElement) return;
        const rect = renderer.domElement.getBoundingClientRect();
        pointer.x = ((ev.clientX - rect.left) / rect.width) * 2 - 1;
        pointer.y = -((ev.clientY - rect.top) / rect.height) * 2 + 1;
        pointerClientPos.x = ev.clientX;
        pointerClientPos.y = ev.clientY;
      }

      function handlePointerLeave() {
        pointer.set(0, 0);
        pointerClientPos.x = 0;
        pointerClientPos.y = 0;
        hideTooltip();
      }

      function hideTooltip() {
        if (tooltipEl) {
          tooltipEl.style.opacity = 0;
        }
      }

      function getCurrentTotalPanels() {
        // Prefer the *actual rendered geometry* count when available.
        // This prevents drift when rebuildArrayGeometry() changes row counts, ridge logic,
        // cloning/tiling behavior, or panel template composition.
        try {
          if (Array.isArray(panelMeshes) && panelMeshes.length > 0) {
            return Math.max(0, panelMeshes.length | 0);
          }
        } catch (e) {
          // fall back to analytic estimate below
        }

        const type = (arrayTypeEl && arrayTypeEl.value === "roof") ? "roof" : "waves";
        let base = 0;

        if (type === "waves") {
          const panelsPerRow = parseInt(wavesPanelsPerRowEl.value || "5", 10);
          const rowsFixed = 18; // fixed for Solar Waves geometry in this app
          base = Math.max(0, panelsPerRow) * rowsFixed;
        } else {
          const cols = parseInt(roofColsEl.value || "20", 10);
          const rows = parseInt(roofRowsEl.value || "4", 10);
          base = Math.max(0, cols) * Math.max(0, rows);
        }

        // Ground-only: multiply by array-of-arrays tiling counts (X/Y)
        const surface = (surfaceTypeEl && surfaceTypeEl.value) ? String(surfaceTypeEl.value).toLowerCase() : "ground";
        if (surface === "ground") {
          const counts = getGroundTileCounts();
          const tileX = Math.max(1, counts.x | 0);
          const tileY = Math.max(1, counts.y | 0);
          base *= (tileX * tileY);
        }

        return Math.max(0, base | 0);
      }

      // Expose for console debugging (script is inside an IIFE, so functions aren't on window by default)
      try { window.getCurrentTotalPanels = getCurrentTotalPanels; } catch (_) {}

      function ensureUniqueMaterial(mesh) {
        if (!mesh || !mesh.material) return;
        if (mesh.userData && mesh.userData.__uniqueMaterial) return;
        // If the same material instance is shared across many meshes,
        // per-mesh color/emissive edits will appear uniform. Clone once.
        if (Array.isArray(mesh.material)) {
          mesh.material = mesh.material.map(m => (m && m.clone ? m.clone() : m));
        } else if (mesh.material.clone) {
          mesh.material = mesh.material.clone();
        }
        mesh.userData = mesh.userData || {};
        mesh.userData.__uniqueMaterial = true;
      }

      function computeRobustMinMax(values, fallbackMin=0, fallbackMax=1000) {
        const finite = values.filter(v => Number.isFinite(v));
        if (!finite.length) return { min: fallbackMin, max: fallbackMax };
        const sorted = finite.slice().sort((a,b)=>a-b);
        const q = (p) => {
          const idx = (sorted.length - 1) * p;
          const lo = Math.floor(idx);
          const hi = Math.ceil(idx);
          if (lo === hi) return sorted[lo];
          const t = idx - lo;
          return sorted[lo] * (1 - t) + sorted[hi] * t;
        };
        let min = q(0.05);
        let max = q(0.95);
        if (!(max > min)) { min = Math.min(...sorted); max = Math.max(...sorted); }
        if (!(max > min)) { const c = Number.isFinite(min) ? min : fallbackMin; const eps = Math.max(1, 0.02 * Math.abs(c)); min = c - eps; max = c + eps; }
        return { min, max };
      }

      function updateLegendUI({ min, max, meanText, noteText }) {
        if (legendMinEl) legendMinEl.textContent = `${Number(min).toFixed(0)}`;
        if (legendMaxEl) legendMaxEl.textContent = `${Number(max).toFixed(0)}`;
        if (legendMeanEl && meanText != null) legendMeanEl.textContent = meanText;
        if (legendNoteEl && noteText != null) legendNoteEl.textContent = noteText;
        updateLegendBar(min, max);
      }

      function updateLegendBar(min, max) {
        const bar = document.getElementById("legend-bar");
        if (!bar) return;
        const steps = 10;
        const cols = [];
        for (let i = 0; i < steps; i++) {
          const t = i / (steps - 1);
          const v = min + t * (max - min);
          const c = scalarToColor(v, min, max);
          const r = Math.round(c.r * 255);
          const g = Math.round(c.g * 255);
          const b = Math.round(c.b * 255);
          cols.push(`rgb(${r},${g},${b}) ${(t*100).toFixed(1)}%`);
        }
        bar.style.background = `linear-gradient(90deg, ${cols.join(",")})`;
      }


      function initThree() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xd2d6df);

        const aspect = canvasContainer.clientWidth / canvasContainer.clientHeight || 1.7;
        camera = new THREE.PerspectiveCamera(45, aspect, 0.1, 500);
        camera.position.set(34, 26, 32);
        camera.lookAt(0, 0, 0);

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.physicallyCorrectLights = true;
        // Professional rendering defaults (engineering review-friendly)
        if ('outputColorSpace' in renderer && THREE.SRGBColorSpace) {
          renderer.outputColorSpace = THREE.SRGBColorSpace;
        } else if ('outputEncoding' in renderer && THREE.sRGBEncoding) {
          renderer.outputEncoding = THREE.sRGBEncoding;
        }
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1.0;

        renderer.setPixelRatio(window.devicePixelRatio || 1);
        renderer.setSize(canvasContainer.clientWidth, canvasContainer.clientHeight);
        canvasContainer.appendChild(renderer.domElement);
        renderer.domElement.addEventListener("pointermove", handlePointerMove);
        renderer.domElement.addEventListener("pointerleave", handlePointerLeave);

        const hemi = new THREE.HemisphereLight(0xffffff, 0x444444, 0.35);
        hemi.position.set(0, 40, 0);
        scene.add(hemi);

        // Sun light (directional) with shadow map enabled
        sunLight = new THREE.DirectionalLight(0xffffff, 1.6);
        sunLight.position.set(20, 40, -10);
        sunLight.castShadow = true;

        // Shadow map quality (tune later)
        sunLight.shadow.mapSize.width = 2048;
        sunLight.shadow.mapSize.height = 2048;
        sunLight.shadow.bias = -0.0002;
        sunLight.shadow.normalBias = 0.02;

        // Orthographic shadow camera bounds (updated dynamically later)
        const d = 40;
        sunLight.shadow.camera.left = -d;
        sunLight.shadow.camera.right = d;
        sunLight.shadow.camera.top = d;
        sunLight.shadow.camera.bottom = -d;
        sunLight.shadow.camera.near = 0.5;
        sunLight.shadow.camera.far = 200;

        scene.add(sunLight);
        scene.add(sunLight.target);

        // Enable renderer shadows
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

const groundGeom = new THREE.PlaneGeometry(groundSize, groundSize);
        const groundMat = new THREE.MeshLambertMaterial({ color: 0xc3f4f6, side: THREE.DoubleSide });
        groundMesh = new THREE.Mesh(groundGeom, groundMat);
        groundMesh.name = "groundMesh";
        groundMesh.userData = groundMesh.userData || {};
        groundMesh.userData._svfIgnore = true;
        groundMesh.userData._isSurfacePlane = true;
        // ground geometry is pre-rotated into XZ; keep mesh rotation at yaw only.
        scene.add(groundMesh);

        groundMesh.receiveShadow = true;
        groundMesh.castShadow = false;

        // Water shadow overlay: single-color shadow using alphaMap (avoids banding/stripes)
        waterShadowMesh = new THREE.Mesh(groundGeom.clone(), new THREE.MeshBasicMaterial({
          color: 0x000000,
          transparent: true,
          opacity: 0.28,
          depthWrite: false
        }));
        waterShadowMesh.name = "waterShadowMesh";
        waterShadowMesh.userData = waterShadowMesh.userData || {};
        waterShadowMesh.userData._svfIgnore = true;
        waterShadowMesh.userData._isShadowHelper = true;
        waterShadowMesh.visible = false;
        waterShadowMesh.renderOrder = 4;
        scene.add(waterShadowMesh);

        directionGroup = new THREE.Group();
        directionGroup.visible = !!SHOW_DIRECTION_MARKERS;
        scene.add(directionGroup);

        initNorthArrow();

        arrayGroup = new THREE.Group();
        scene.add(arrayGroup);

        
        // Root for anything that should rotate/move together (azimuth, etc.)
        tiledRoot = new THREE.Group();
        tiledRoot.name = "tiledRoot";
        arrayGroup.add(tiledRoot);


        // Ensure the surface plane rotates with the array yaw: parent groundMesh under tiledRoot.
        if (groundMesh) {
          if (groundMesh.parent) groundMesh.parent.remove(groundMesh);
          tiledRoot.add(groundMesh);
        }
        wavesGroup = new THREE.Group();
        roofGroup = new THREE.Group();
        tiledRoot.add(wavesGroup);
        tiledRoot.add(roofGroup);

        // Ground-only tiling clones live here (kept empty for non-ground or 1×1)
        groundTilingGroup = new THREE.Group();
        groundTilingGroup.name = "groundTilingGroup";
        groundTilingGroup.userData = groundTilingGroup.userData || {};
        groundTilingGroup.userData._isTilingContainer = true;
        tiledRoot.add(groundTilingGroup);

        wavesGroup.visible = true;
        roofGroup.visible = false;
        shadowProjectionGroup = new THREE.Group();
        shadowProjectionGroup.renderOrder = 5;
        scene.add(shadowProjectionGroup);
        contourGroup = new THREE.Group();
        contourGroup.visible = !!SHOW_SNAPSHOT_CONTOURS;
        contourGroup.renderOrder = 6;
        scene.add(contourGroup);
        projectedShadowMaterial = new THREE.MeshBasicMaterial({
          color: 0x000000,
          opacity: 0.28,
          transparent: true,
          depthWrite: false
        });
        controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.08;
        controls.rotateSpeed = 0.7;
        controls.panSpeed = 0.5;
        controls.target.set(0, 0, 0);
        initShadowSampling();
        window.addEventListener("resize", handleResize);
        animate();
      }

      // ============================================================
      // GPU shadow/transmittance sampling (beam shading proxy)
      // ============================================================

      function initShadowSampling() {
        // Render target where we draw the surface shadow mask
        shadowRT = new THREE.WebGLRenderTarget(shadowResInteractive, shadowResInteractive, {
          depthBuffer: true,
          stencilBuffer: false
        });
        shadowReadBuf = new Uint8Array(shadowResInteractive * shadowResInteractive * 4);

        shadowCam = new THREE.OrthographicCamera(-1, 1, 1, -1, 0.1, 50);
        shadowCam.position.set(0, 10, 0);
        shadowCam.lookAt(0, 0, 0);

        // ShadowMaterial draws darkness in shadow; opacity=1 gives a clean mask
        shadowMat = new THREE.ShadowMaterial({ opacity: 1.0 });
      }

      function syncShadowPlaneToGround() {
        if (!groundMesh || !shadowCam) return;

        // Fit ortho camera to the plane extents (in plane local space)
        shadowCam.left = -groundDims.sx / 2;
        shadowCam.right = groundDims.sx / 2;
        shadowCam.top = groundDims.sz / 2;
        shadowCam.bottom = -groundDims.sz / 2;
        shadowCam.near = 0.01;
        shadowCam.far = 50;
        shadowCam.updateProjectionMatrix();

        // Place camera above plane. We also rotate the camera "up" vector to match the ground's yaw,
        // so the resulting renderTarget aligns with the ground UVs (prevents 'sticky' / rotated shadow textures).
        const groundPos = groundMesh.position;
        shadowCam.position.set(groundPos.x, groundPos.y + 10, groundPos.z);

        // Align camera's screen-space axes to ground local axes via the up-vector.
        // (For a top-down ortho camera, this controls the renderTarget rotation.)
        const upVec = new THREE.Vector3(0, 0, 1).applyQuaternion(groundMesh.quaternion).normalize();
        shadowCam.up.copy(upVec);
        shadowCam.lookAt(groundPos.x, groundPos.y, groundPos.z);
        shadowCam.updateMatrixWorld(true);

        // Keep overlay in sync
        if (shadowOverlayMesh) {
          shadowOverlayMesh.position.copy(groundMesh.position);
          shadowOverlayMesh.rotation.copy(groundMesh.rotation);
          shadowOverlayMesh.scale.set(groundDims.sx, 1, groundDims.sz);
          shadowOverlayMesh.position.y = groundMesh.position.y + 0.01;
        }
      }


function ensureShadowOverlay() {
  if (!groundMesh || !shadowRT) return;
  if (shadowOverlayMesh) return;

  const geom = new THREE.PlaneGeometry(1, 1);
  geom.rotateX(-Math.PI / 2);

  const mat = new THREE.MeshBasicMaterial({
    map: shadowRT.texture,
    transparent: true,
    opacity: 0.7,
    color: 0xffffff,
    blending: THREE.MultiplyBlending,
    depthWrite: false
  });

  shadowOverlayMesh = new THREE.Mesh(geom, mat);
  shadowOverlayMesh.name = "shadowOverlayMesh";
  shadowOverlayMesh.userData = shadowOverlayMesh.userData || {};
  shadowOverlayMesh.userData._svfIgnore = true;
  shadowOverlayMesh.userData._isShadowHelper = true;
  shadowOverlayMesh.renderOrder = 10;
  shadowOverlayMesh.visible = false;
  shadowOverlayMesh.rotation.copy(groundMesh.rotation);
  shadowOverlayMesh.position.copy(groundMesh.position);
  shadowOverlayMesh.position.y += 0.01; // avoid z-fighting
  shadowOverlayMesh.scale.set(groundDims.sx, 1, groundDims.sz);
  scene.add(shadowOverlayMesh);
}

      function setSunDirectionFromAzEl(azDeg, elDeg) {
        // Debug lock: freeze sun direction during tests (prevents other UI/loops overwriting it)
        // Allow an explicit bypass (used by __pvTestSun) so we can set a known sun even while locked.
        if (window.__lockSun === true && window.__lockSunBypass !== true) return;
        if (!sunLight) return;

        // Diagnostics
        window.__sunCalls = (window.__sunCalls || 0) + 1;

        lastSunAzDeg = azDeg;
        lastSunElDeg = elDeg;

        const az = degToRad(azDeg);
        const el = degToRad(elDeg);

        // World convention in this app: North = -Z, East = +X
        const dir = new THREE.Vector3(
          Math.sin(az) * Math.cos(el),  // x
          Math.sin(el),                 // y
          -Math.cos(az) * Math.cos(el)  // z
        ).normalize();

        window.__sunDirToSun = window.__sunDirToSun || new THREE.Vector3();
        window.__sunDirToSun.copy(dir).normalize();  // <-- use the same variable name you have there
        window.__sunLast = { azDeg, elDeg, sun: window.__sunDirToSun.toArray(), calls: window.__sunCalls };

        const center = groundMesh ? groundMesh.position.clone() : new THREE.Vector3(0, 0, 0);

        // DirectionalLight shines from its position toward its target.
        sunLight.target.position.copy(center);

        const lightDistance = 120; // keep fairly far to reduce perspective artifacts in shadows
        sunLight.position.copy(center.clone().add(dir.clone().multiplyScalar(lightDistance)));

        // Keep shadow camera bounds in sync with the current scene footprint
        syncSunShadowCameraToGround();

        sunLight.updateMatrixWorld(true);
        sunLight.target.updateMatrixWorld(true);

        updateProjectedShadow();
      }

      // Debug helper: set a known sun while optionally keeping the global lock enabled
      window.__pvTestSun = async function(azDeg = 0, elDeg = 60) {
        const wasLocked = (window.__lockSun === true);
        window.__lockSunBypass = true;
        try {
          // Even if __lockSun is true, this call will now go through.
          setSunDirectionFromAzEl(azDeg, elDeg);
          await nextFrame();
          console.log("[PVTEST] sun", { azDeg, elDeg, dirToSun: window.__sunDirToSun?.toArray?.() });
        } finally {
          window.__lockSunBypass = false;
          // Keep the user's lock setting as-is
          window.__lockSun = wasLocked;
        }
      };

      function syncSunShadowCameraToGround() {
        if (!sunLight || !sunLight.shadow || !sunLight.shadow.camera) return;
        if (!groundMesh) return;

        // Expand bounds slightly to ensure the full ground footprint stays inside the shadow frustum.
        const pad = 8.0;
        const halfW = Math.max(10, groundDims.sx * 0.5 + pad);
        const halfH = Math.max(10, groundDims.sz * 0.5 + pad);

        const cam = sunLight.shadow.camera;
        cam.left = -halfW;
        cam.right = halfW;
        cam.top = halfH;
        cam.bottom = -halfH;

        // Near/far should cover from light to receivers/occluders
        cam.near = 0.5;
        cam.far = 400;

        cam.updateProjectionMatrix();
      }

      function updateRealtimeSunAndHeatmap() {
        if (!currentLocation) return;

        // Snapshot mode keeps its own locked sun direction and uses snapshot-derived colors.
        if (snapshotSunLock) {
          setSunDirectionFromAzEl(snapshotSunLock.az, snapshotSunLock.el);
          return;
        }

        // Use *actual current time* in UTC for "real-time" sun direction.
        const t = new Date();
        const sp = solarPositionApproxUTC(t, Number(currentLocation.lat), Number(currentLocation.lon));

        // If sun is below the horizon, keep a low grazing angle (prevents shadow-map glitches)
        const el = Number.isFinite(sp.el_deg) ? sp.el_deg : 5;
        const az = Number.isFinite(sp.az_deg) ? sp.az_deg : 180;

        setSunDirectionFromAzEl(az, Math.max(-2, el));

        // Realtime shading: use GPU shadow mask (tau) to modulate POA per panel.
        // Prevent overlapping async ticks (avoids mixed overlays from interleaved updates).
        if (_realtimeUpdateBusy) return;
        _realtimeUpdateBusy = true;
        const myToken = ++_realtimeUpdateToken;

        try {
          computeBeamTransmittanceGPU();
          if (myToken !== _realtimeUpdateToken) return; // invalidated by a newer tick/rebuild
          applyPerPanelShadowGradient();
        } catch (err) {
          applyPanelHeatmapFromSun();
        } finally {
          if (myToken === _realtimeUpdateToken) _realtimeUpdateBusy = false;
        }
      }


      function applyPanelHeatmapFromSun() {
        if (currentRenderMode === 'textures') return;
        if (useSnapshotColors) return;
        if (!sunLight || panelMeshes.length === 0) return;

        // Sun direction (light travel direction is from sunLight.position -> target).
        const sunDir = new THREE.Vector3().subVectors(sunLight.target.position, sunLight.position).normalize();
        const sunRay = sunDir.clone().negate(); // direction from surface toward the sun

        // Ensure realtime meteo cache is available once per frame (not per panel)
        ensureRealtimeMeteo();
        const tNow = new Date();
        const irrNow = getIrradianceAtUTC(tNow);

        const q = new THREE.Quaternion();
        const nLocal = new THREE.Vector3(0, 1, 0);
        const nWorld = new THREE.Vector3();

for (const m of panelMeshes) {
          if (!m || !m.material || !m.material.color) continue;
          m.getWorldQuaternion(q);
          nWorld.copy(nLocal).applyQuaternion(q).normalize();

          // Real-time POA (W/m²): prefer hourly irradiance from Open-Meteo (DNI/DHI/GHI),
          // fallback to a stable proxy if meteo isn't available yet.
          const irr = irrNow;
          let poa = computePOA_Wm2_fromIrradiance(nWorld, sunRay, irr, surfaceEl ? surfaceEl.value : "");
          if (!(poa > 0) && poa !== 0) {
            // Fallback proxy: avoids everything looking "minimum" if meteo fetch hasn't completed.
            const cosInc = Math.max(0, nWorld.dot(sunRay));
            const diffuseProxy = 200;        // W/m² baseline
            const beamProxy = 800 * cosInc;  // W/m² scaled by incidence
            poa = diffuseProxy + beamProxy;
          }

          const col = scalarToColor(poa, minI, maxI);
          // Make the heatmap readable even if normals are inverted: drive colour via emissive.
          m.material.color.set(0x000000);
          if (m.material.emissive) {
            m.material.emissive.copy(col);
            m.material.emissiveIntensity = 1.0;
          }
          m.material.metalness = 0.0;
          m.material.roughness = 1.0;
        }
      }

      function updateProjectedShadow() {
        if (!shadowProjectionGroup) return;

        while (shadowProjectionGroup.children.length) {
          const obj = shadowProjectionGroup.children.pop();
          if (obj.geometry) obj.geometry.dispose();
          shadowProjectionGroup.remove(obj);
        }

        if (!sunLight || !groundMesh || panelMeshes.length === 0) return;

        const sunDir = new THREE.Vector3().subVectors(sunLight.target.position, sunLight.position).normalize();
        const rayDir = sunDir.clone().negate();
        if (rayDir.y >= -0.05) {
          return; // sun below horizon, skip
        }

        const groundY = groundMesh.position.y;
        const cornersLocal = [
          new THREE.Vector3(-currentPanelDims.w / 2, 0, -currentPanelDims.h / 2),
          new THREE.Vector3(currentPanelDims.w / 2, 0, -currentPanelDims.h / 2),
          new THREE.Vector3(currentPanelDims.w / 2, 0, currentPanelDims.h / 2),
          new THREE.Vector3(-currentPanelDims.w / 2, 0, currentPanelDims.h / 2)
        ];

        const projected = new Array(4);
        const tmp = new THREE.Vector3();
        const offsets = cornersLocal.map(v => v.clone());

        for (const panel of panelMeshes) {
          if (!panel.matrixWorld) continue;
          let valid = true;
          for (let i = 0; i < offsets.length; i++) {
            const corner = offsets[i].clone().applyMatrix4(panel.matrixWorld);
            const t = (groundY - corner.y) / rayDir.y;
            if (!Number.isFinite(t) || t < 0) {
              valid = false;
              break;
            }
            projected[i] = corner.clone().add(tmp.copy(rayDir).multiplyScalar(t));
          }
          if (!valid) continue;

          const positions = new Float32Array([
            projected[0].x, projected[0].y, projected[0].z,
            projected[1].x, projected[1].y, projected[1].z,
            projected[2].x, projected[2].y, projected[2].z,
            projected[2].x, projected[2].y, projected[2].z,
            projected[3].x, projected[3].y, projected[3].z,
            projected[0].x, projected[0].y, projected[0].z
          ]);

          const geom = new THREE.BufferGeometry();
          geom.setAttribute("position", new THREE.BufferAttribute(positions, 3));
          geom.computeVertexNormals();
          const mesh = new THREE.Mesh(geom, projectedShadowMaterial);
          mesh.position.y = groundY + 0.001;
          shadowProjectionGroup.add(mesh);
        }
      }

      function applySnapshotData(data) {
        snapshotData = data;
        orientationSnapshotMap.clear();
        (data.orientations || []).forEach(o => {
          orientationSnapshotMap.set(o.orientation_key, o);
        });
        snapshotSunLock = {
          az: Number(data.snapshot_sun_az_deg),
          el: Number(data.snapshot_sun_el_deg)
        };
        useSnapshotColors = true;
        if (
          Number.isFinite(snapshotSunLock.az) &&
          Number.isFinite(snapshotSunLock.el)
        ) {
          setSunDirectionFromAzEl(snapshotSunLock.az, snapshotSunLock.el);
        }
        applySnapshotPanelColors();
        rebuildSnapshotContours();
        updateProjectedShadow();
        try {
          computeBeamTransmittanceGPU();
          applyPerPanelShadowGradient();
        } catch (err) {
          // ignore shading errors in snapshot mode
        }
      }

      function applySnapshotPanelColors() {
        if (currentRenderMode === 'textures') return;
        if (!snapshotData || !panelMeshes.length || orientationSnapshotMap.size === 0) return;
        const values = Array.from(orientationSnapshotMap.values())
          .map(o => Number(o.daily_mean_poa_w_m2))
          .filter(v => Number.isFinite(v));
        if (!values.length) return;
        let min = Math.min(...values);
        let max = Math.max(...values);
        if (!Number.isFinite(min)) min = 0;
        if (!Number.isFinite(max) || max === min) max = min + 1;
        snapshotColorRange = { min, max };

        panelMeshes.forEach(mesh => {
          ensurePanelOrientationKey(mesh);
          const key = mesh.userData && mesh.userData.orientationKey;
          const entry = key ? orientationSnapshotMap.get(key) : null;

          ensureUniqueMaterial(mesh);

          const raw = entry ? Number(entry.daily_mean_poa_w_m2) : NaN;
          const hasVal = Number.isFinite(raw);
          const val = hasVal ? raw : NaN;

          if (!hasVal) {
            // Fallback: neutral colour when snapshot entry is missing (prevents stale/default bands after rebuild).
            mesh.material.color.set(0x000000);
            if (mesh.material.emissive) {
              mesh.material.emissive.set(0x666666);
              mesh.material.emissiveIntensity = 0.7;
            }
            mesh.material.metalness = 0.0;
            mesh.material.roughness = 1.0;
            mesh.material.needsUpdate = true;
            mesh.userData.snapshotValue = null;
            return;
          }

          mesh.userData.snapshot_base_poa_w_m2 = val;
          const col = scalarToColor(val, min, max);
          mesh.material.color.set(0x000000);
          if (mesh.material.emissive) {
            mesh.material.emissive.copy(col);
            mesh.material.emissiveIntensity = 1.0;
          }
          // Reduce reliance on mesh normals for readability (inverted normals would otherwise appear "dark")
          mesh.material.metalness = 0.0;
          mesh.material.roughness = 1.0;
          mesh.material.needsUpdate = true;
          mesh.userData.snapshotValue = val;
        });
        snapshotLegendMinMax = { min, max };
        currentLegendMode = 'snapshot';
        updateLegendUI({
          min,
          max,
          meanText: `Snapshot day: ${snapshotData.snapshot_day}`,
          noteText: 'Higher colour = higher snapshot POA (W/m²)'
        });
      }

      function rebuildSnapshotContours() {
        if (!SHOW_SNAPSHOT_CONTOURS) {
          // Ensure nothing is shown if disabled
          if (contourGroup) {
            while (contourGroup.children.length) {
              const obj = contourGroup.children.pop();
              if (obj && obj.geometry) obj.geometry.dispose?.();
              contourGroup.remove(obj);
            }
          }
          return;
        }
        if (!contourGroup) return;
        while (contourGroup.children.length) {
          const obj = contourGroup.children.pop();
          if (obj.geometry) obj.geometry.dispose();
          contourGroup.remove(obj);
        }
        if (!snapshotData || orientationSnapshotMap.size === 0) return;
        const min = snapshotColorRange.min;
        const max = snapshotColorRange.max || min + 1;
        orientationSnapshotMap.forEach((entry, key) => {
          const panels = panelMeshes.filter(m => m.userData.orientationKey === key);
          if (!panels.length) return;
          const box = new THREE.Box3();
          panels.forEach(p => box.expandByObject(p));
          if (!isFinite(box.min.x) || !isFinite(box.max.x)) return;
          const height = box.min.y + 0.02;
          const points = [
            new THREE.Vector3(box.min.x, height, box.min.z),
            new THREE.Vector3(box.max.x, height, box.min.z),
            new THREE.Vector3(box.max.x, height, box.max.z),
            new THREE.Vector3(box.min.x, height, box.max.z)
          ];
          const geom = new THREE.BufferGeometry().setFromPoints(points.concat(points[0]));
          const col = scalarToColor(entry.daily_mean_poa_w_m2 || min, min, max);
          const line = new THREE.Line(geom, new THREE.LineBasicMaterial({ color: col.getHex(), linewidth: 1 }));
          contourGroup.add(line);

          const center = box.getCenter(new THREE.Vector3());
          const label = createTextSprite(`${(entry.daily_mean_poa_w_m2 || 0).toFixed(0)} W/m²`);
          label.position.copy(center);
          label.position.y = height + 0.3;
          contourGroup.add(label);
        });
      }


      function findParentPanelMesh(obj) {
        let cur = obj;
        while (cur) {
          if (cur.userData && cur.userData.isPanel) return cur;
          if (cur.userData && cur.userData.parentPanel) return cur.userData.parentPanel;
          cur = cur.parent;
        }
        return null;
      }

      function updateHoverTooltip() {
        if (!tooltipEl || !snapshotData || !useSnapshotColors) {
          hideTooltip();
          return;
        }
        const targets = [];
        panelMeshes.forEach(m => targets.push(m));
        if (groundMesh) targets.push(groundMesh);
        if (!targets.length) {
          hideTooltip();
          return;
        }
        raycaster.setFromCamera(pointer, camera);
        const hits = raycaster.intersectObjects(targets, true);
        if (!hits.length) {
          hideTooltip();
          return;
        }
        for (const hit of hits) {
          const panel = findParentPanelMesh(hit.object);
          if (panel) {
            showPanelTooltip(panel);
            return;
          }
          if (hit.object === groundMesh) {
            showGroundTooltip();
            return;
          }
        }
        hideTooltip();
      }

      function showPanelTooltip(panel) {
        const key = panel.userData.orientationKey;
        const entry = orientationSnapshotMap.get(key);
        if (!entry) {
          hideTooltip();
          return;
        }
        tooltipEl.innerHTML =
          `<div><strong>Panel snapshot</strong></div>` +
          `<div>Orientation: ${entry.azimuth_deg.toFixed(1)}° / Tilt ${entry.tilt_deg.toFixed(1)}°</div>` +
          `<div>Daily mean POA: ${entry.daily_mean_poa_w_m2.toFixed(1)} W/m²</div>` +
          `<div>Snapshot day: ${snapshotData.snapshot_day}</div>`;
        tooltipEl.style.left = pointerClientPos.x + 12 + "px";
        tooltipEl.style.top = pointerClientPos.y + 12 + "px";
        tooltipEl.style.opacity = 1;
      }

      function showGroundTooltip() {
        tooltipEl.innerHTML =
          `<div><strong>Ground snapshot</strong></div>` +
          `<div>Day: ${snapshotData ? snapshotData.snapshot_day : "n/a"}</div>` +
          `<div>Sun: ${snapshotSunLock ? snapshotSunLock.az.toFixed(1) : "–"}° az, ` +
          `${snapshotSunLock ? snapshotSunLock.el.toFixed(1) : "–"}° el</div>` +
          `<div>Beam transmittance: ${(lastBeamTransmittance * 100).toFixed(1)}%</div>`;
        tooltipEl.style.left = pointerClientPos.x + 12 + "px";
        tooltipEl.style.top = pointerClientPos.y + 12 + "px";
        tooltipEl.style.opacity = 1;
      }

function computeArrayFootprintLocalXZ() {
  // Returns {minX, maxX, minZ, maxZ} in ground plane local coords, or null.
  if (!groundMesh) return null;

  const target =
    (wavesGroup && wavesGroup.visible) ? wavesGroup :
    (roofGroup && roofGroup.visible) ? roofGroup :
    null;

  if (!target) return null;

  const box = new THREE.Box3().setFromObject(target);
  if (!isFinite(box.min.x) || !isFinite(box.max.x)) return null;

  const corners = [
    new THREE.Vector3(box.min.x, box.min.y, box.min.z),
    new THREE.Vector3(box.min.x, box.min.y, box.max.z),
    new THREE.Vector3(box.min.x, box.max.y, box.min.z),
    new THREE.Vector3(box.min.x, box.max.y, box.max.z),
    new THREE.Vector3(box.max.x, box.min.y, box.min.z),
    new THREE.Vector3(box.max.x, box.min.y, box.max.z),
    new THREE.Vector3(box.max.x, box.max.y, box.min.z),
    new THREE.Vector3(box.max.x, box.max.y, box.max.z),
  ];

  const inv = new THREE.Matrix4().copy(groundMesh.matrixWorld).invert();
  let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;

  for (const c of corners) {
    c.applyMatrix4(inv);
    minX = Math.min(minX, c.x);
    maxX = Math.max(maxX, c.x);
    minZ = Math.min(minZ, c.z);
    maxZ = Math.max(maxZ, c.z);
  }

  if (!isFinite(minX) || !isFinite(maxX) || !isFinite(minZ) || !isFinite(maxZ)) return null;
  return { minX, maxX, minZ, maxZ };
}

function computeArrayFootprintGroundLocalXZ() {
  if (!arrayGroup || !groundMesh) return null;

  // World-axis-aligned bounding box of the array geometry
  const boxW = new THREE.Box3().setFromObject(arrayGroup);
  if (!Number.isFinite(boxW.min.x) || !Number.isFinite(boxW.max.x)) return null;

  // Project to ground plane in WORLD space (y = 0)
  // Use world X/Z from the box, but force y=0 so elevation never affects footprint.
  const ptsW = [
    new THREE.Vector3(boxW.min.x, 0, boxW.min.z),
    new THREE.Vector3(boxW.min.x, 0, boxW.max.z),
    new THREE.Vector3(boxW.max.x, 0, boxW.min.z),
    new THREE.Vector3(boxW.max.x, 0, boxW.max.z),
  ];

  let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;

  for (const p of ptsW) {
    // Convert to ground local space
    const pl = p.clone();
    groundMesh.worldToLocal(pl);

    // Footprint is in ground local XZ
    if (pl.x < minX) minX = pl.x;
    if (pl.x > maxX) maxX = pl.x;
    if (pl.z < minZ) minZ = pl.z;
    if (pl.z > maxZ) maxZ = pl.z;
  }

  if (!Number.isFinite(minX) || !Number.isFinite(minZ)) return null;
  return { minX, maxX, minZ, maxZ };
}

      function computeBeamTransmittanceGPU() {
        if (!renderer || !shadowRT || !shadowCam || !shadowMat || !groundMesh) return 1.0;

        syncShadowPlaneToGround();

        const prevRT = renderer.getRenderTarget();
        const prevOverride = scene.overrideMaterial;
        const prevShadowAutoUpdate = renderer.shadowMap.autoUpdate;
        const prevGroundMaterial = groundMesh.material;
        const prevOverlayVisible = shadowOverlayMesh ? shadowOverlayMesh.visible : null;
        if (shadowOverlayMesh) shadowOverlayMesh.visible = false;

        renderer.shadowMap.autoUpdate = false;
        scene.overrideMaterial = null;
        groundMesh.material = shadowMat;

        renderer.setRenderTarget(shadowRT);
        renderer.clear();
        renderer.render(scene, shadowCam);
        renderer.setRenderTarget(prevRT);

        groundMesh.material = prevGroundMaterial;
        scene.overrideMaterial = prevOverride;
        renderer.shadowMap.autoUpdate = prevShadowAutoUpdate;
        renderer.shadowMap.needsUpdate = true;
        if (shadowOverlayMesh) shadowOverlayMesh.visible = false;

        // Read back pixels (RGBA 0..255)
        renderer.readRenderTargetPixels(
          shadowRT,
          0, 0,
          shadowRT.width, shadowRT.height,
          shadowReadBuf
        );

        
// Persist the full-resolution shadow mask for downstream per-panel + ground/water shading.
        // (Uint8Array RGBA, values 0..255, where brighter => more lit)
        lastShadowMaskPixels = shadowReadBuf;
        lastShadowMaskW = shadowRT.width;
        lastShadowMaskH = shadowRT.height;

        // Tag ownership (Water only) to prevent stale masks from other array types / geometry.
        try {
          const surf = (surfaceTypeEl && surfaceTypeEl.value) ? String(surfaceTypeEl.value).toLowerCase() : "";
          if (surf === "water") {
            const at = (arrayTypeEl && arrayTypeEl.value === "roof") ? "roof" : "waves";
            const key = computeWaterCacheKey();
            lastShadowMaskOwnerKey = key;
            lastShadowMaskOwnerType = at;
            if (waterMaskStateByType && waterMaskStateByType[at]) {
              waterMaskStateByType[at].key = key;
              waterMaskStateByType[at].pixels = lastShadowMaskPixels;
              waterMaskStateByType[at].w = lastShadowMaskW;
              waterMaskStateByType[at].h = lastShadowMaskH;
            }
          } else {
            lastShadowMaskOwnerKey = null;
            lastShadowMaskOwnerType = null;
          }
        } catch (e) {}

        // Update water surface texture (ground mode keeps it disabled)
        updateGroundShadowTextureFromMask(lastShadowMaskPixels, lastShadowMaskW, lastShadowMaskH);

// ShadowMaterial yields darker pixels in shadow; compute mean lit fraction in [0..1]
const w = shadowRT.width;
const h = shadowRT.height;

function meanInRect(x0, y0, x1, y1) {
  const ix0 = Math.max(0, Math.min(w - 1, Math.floor(x0)));
  const iy0 = Math.max(0, Math.min(h - 1, Math.floor(y0)));
  const ix1 = Math.max(0, Math.min(w, Math.ceil(x1)));
  const iy1 = Math.max(0, Math.min(h, Math.ceil(y1)));

  let sum = 0;
  let cnt = 0;
  for (let y = iy0; y < iy1; y++) {
    for (let x = ix0; x < ix1; x++) {
      const i = (y * w + x) * 4;
      const r = shadowReadBuf[i + 0];
      const g = shadowReadBuf[i + 1];
      const b = shadowReadBuf[i + 2];
      sum += (r + g + b) / 3;
      cnt++;
    }
  }
  return cnt ? (sum / (cnt * 255)) : 1.0;
}

// Mean over full plane
lastBeamTransmittanceFull = Math.max(0, Math.min(1, meanInRect(0, 0, w, h)));

// Mean under array footprint (prevents dilution by large margins)
const fp = computeArrayFootprintGroundLocalXZ();

if (window.DEBUG_SHADING) {
  const now = Date.now();
  if (!window.__fpLastLogTime || (now - window.__fpLastLogTime) > 500) {
    window.__fpLastLogTime = now;
    console.log("[FOOTPRINT RAW]", {
      elev_m: elevationEl ? Number(elevationEl.value) : null,
      az_ui: azimuthEl ? Number(azimuthEl.value) : null,
      fp,
      groundDims,
      groundPos: groundMesh?.position,
      groundRot: groundMesh?.rotation,
    });
  }
}

if (fp) {
  const sx = groundDims.sx;
  const sz = groundDims.sz;

  // Raw (unclamped) pixel-space rect
  const u0 = (fp.minX / sx + 0.5) * w;
  const u1 = (fp.maxX / sx + 0.5) * w;
  const v0 = (fp.minZ / sz + 0.5) * h;
  const v1 = (fp.maxZ / sz + 0.5) * h;

  // Clamp to render target bounds
  const x0 = Math.max(0, Math.min(w - 1, Math.min(u0, u1)));
  const x1 = Math.max(0, Math.min(w - 1, Math.max(u0, u1)));
  const y0 = Math.max(0, Math.min(h - 1, Math.min(v0, v1)));
  const y1 = Math.max(0, Math.min(h - 1, Math.max(v0, v1)));

  if (window.DEBUG_SHADING) {
    const now = Date.now();
    if (!window.__rectLastLogTime || (now - window.__rectLastLogTime) > 500) {
      window.__rectLastLogTime = now;
      console.log("[MASK RECT px]", {
        elev_m: elevationEl ? Number(elevationEl.value) : null,
        az_ui: azimuthEl ? Number(azimuthEl.value) : null,
        raw: {
          u0: +u0.toFixed(1),
          u1: +u1.toFixed(1),
          v0: +v0.toFixed(1),
          v1: +v1.toFixed(1),
        },
        clamped: {
          x0: +x0.toFixed(1),
          x1: +x1.toFixed(1),
          y0: +y0.toFixed(1),
          y1: +y1.toFixed(1),
        },
        w, h,
      });
    }
  }

  // Avoid degenerate rectangles
  if ((x1 - x0) < 1 || (y1 - y0) < 1) {
    lastBeamTransmittanceUnderArray = lastBeamTransmittanceFull;
  } else {
    lastBeamTransmittanceUnderArray = Math.max(
      0,
      Math.min(1, meanInRect(x0, y0, x1, y1))
    );
  }
} else {
  lastBeamTransmittanceUnderArray = lastBeamTransmittanceFull;
}

// Use under-array as the primary metric
lastBeamTransmittance = lastBeamTransmittanceUnderArray;



// Use under-array as the primary metric
lastBeamTransmittance = lastBeamTransmittanceUnderArray;

// Optional: show shadow overlay on water or when debugging
const surface = (surfaceTypeEl && surfaceTypeEl.value)
  ? String(surfaceTypeEl.value).toLowerCase()
  : "ground";

ensureShadowOverlay();
        // Do not force overlay visibility from within compute; keep it UI-controlled.
        // (Avoids "sticky plane" artifacts when switching surface / azimuth.)
        if (shadowOverlayMesh) {
          const showOverlay = false; // set true only for explicit debug
          shadowOverlayMesh.visible = showOverlay;
          if (shadowOverlayMesh.material) shadowOverlayMesh.material.opacity = surface === "water" ? 0.7 : 0.5;
        }

return lastBeamTransmittance;
      }

      // Expose for debugging in console
      window.computeBeamTransmittanceGPU = computeBeamTransmittanceGPU;

      window._shadingMetrics = () => ({ tau_under_array: lastBeamTransmittanceUnderArray, tau_full: lastBeamTransmittanceFull, tau: lastBeamTransmittance });


async function buildShadingSamplesGPU({ year, lat, lon, mode = "interactive" }) {
  const samples = [];
  const day = 15;

  const savedAz = lastSunAzDeg;
  const savedEl = lastSunElDeg;

  for (let m = 1; m <= 12; m++) {
    const dim = daysInMonthUTC(year, m);
    const hrNoon = approxSolarNoonUtcHourFromLon(lon);
    const weightHoursPerSample = dim * 24.0;

    const hr = hrNoon;
    const time_utc = isoUtcNoZ(year, m, day, hr);
    const t = new Date(Date.UTC(year, m - 1, day, hr, 0, 0));

    const sp = solarPositionApproxUTC(t, Number(lat), Number(lon));
    const elRad = (Math.PI / 2) - sp.zenRad;
    if (!Number.isFinite(elRad) || elRad <= 0.01) continue;

    const azDeg = sp.azRad * 180 / Math.PI;
    const elDeg = elRad * 180 / Math.PI;

    setSunDirectionFromAzEl(azDeg, elDeg);
    await nextFrame();

    const tau = (typeof computeBeamTransmittanceGPU === "function")
      ? Number(computeBeamTransmittanceGPU())
      : 1.0;

    if (!Number.isFinite(tau)) continue;

    samples.push({
      time_utc,
      tau: Math.max(0, Math.min(1, tau)),
      weight_hours: weightHoursPerSample
    });
  }

  // restore sun
  if (Number.isFinite(savedAz) && Number.isFinite(savedEl)) {
    setSunDirectionFromAzEl(savedAz, savedEl);
    await nextFrame();
  }

  return samples;
}

// ============================================================
// PV-plane shading samples (Option 4): tau_pv via raycasting
// ============================================================
// Returns [{time_utc, tau, weight_hours}, ...] suitable as pv_shading_samples
// This computes shading directly on panel faces (NOT water/ground).

function _collectPvOccluders() {
  const occluders = [];
  const seen = new Set();

  // 1) Best: collect deterministically from panelMeshes
  const panels = (typeof window !== "undefined" && Array.isArray(window.panelMeshes))
    ? window.panelMeshes
    : null;

  if (panels && panels.length) {
    for (const p of panels) {
      if (!p?.getObjectByName) continue;

      const occ = p.getObjectByName("pvOcc");
      if (!occ || !occ.isMesh) continue;

      // Prefer explicit flag, but allow name-based fallback
      if (!(occ.userData && occ.userData._isPvOcc === true) && occ.name !== "pvOcc") continue;

      const mat = occ.material;
      if (occ.visible === false) continue;
      if (mat && mat.visible === false) continue;

      if (!seen.has(occ.uuid)) {
        seen.add(occ.uuid);
        occluders.push(occ);
      }
    }

    if (!window.__pvOccOnce) {
      window.__pvOccOnce = true;
      console.log("[PV] occluders (panelMeshes)", { count: occluders.length });
    }
    return occluders;
  }

  // 2) Fallback: traverse arrayGroup
  const root =
    (typeof arrayGroup !== "undefined" && arrayGroup && arrayGroup.traverse)
      ? arrayGroup
      : null;

  if (!root) return occluders;

  root.traverse(obj => {
    if (!obj || !obj.isMesh) return;

    if (obj.name !== "pvOcc") return;
    if (!(obj.userData && obj.userData._isPvOcc === true) && obj.name !== "pvOcc") return;

    const mat = obj.material;
    if (obj.visible === false) return;
    if (mat && mat.visible === false) return;

    if (!seen.has(obj.uuid)) {
      seen.add(obj.uuid);
      occluders.push(obj);
    }
  });

  if (!window.__pvOccOnce) {
    window.__pvOccOnce = true;
    console.log("[PV] occluders (arrayGroup)", { count: occluders.length });
  }

  return occluders;
}

window._collectPvOccluders = _collectPvOccluders;

function computePvTransmittanceRaycast({ nx = 3, ny = 5 } = {}) {
  if (!window.panelMeshes || window.panelMeshes.length === 0) return 1.0;

  // ------------------------------------------------------------
  // Determine mode: roof/canopy should be monofacial + avoid pvOcc
  // ------------------------------------------------------------
  const atEl = document.getElementById("arrayType");
  const atRaw = (atEl && atEl.value ? String(atEl.value) : "waves").toLowerCase();

  // Treat canopy as roof-like (monofacial, planar)
  const isRoofLike =
    (atRaw === "roof") ||
    (atRaw === "canopy") ||
    (atRaw === "solar_canopy") ||
    (atRaw === "solar-canopy") ||
    (atRaw === "solar_roof") ||
    (atRaw === "solar-roof");

  // ------------------------------------------------------------
  // Choose occluders:
  // - Waves: pvOcc slabs (robust)
  // - Roof/Canopy: pvFace planes (avoid coplanar slab false hits)
  // ------------------------------------------------------------
  let occluders = null;

  if (!isRoofLike) {
    occluders = _collectPvOccluders(); // expected pvOcc meshes
  } else {
    // Collect pvFace deterministically from panelMeshes (no scene dependency)
    occluders = [];
    const panels = window.panelMeshes || [];
    for (const p of panels) {
      const face = p?.getObjectByName?.("pvFace");
      if (face?.isMesh) occluders.push(face);
    }
  }

  if (!occluders || occluders.length === 0) return 1.0;

  const raycaster = new THREE.Raycaster();
  raycaster.far = 2000;

  // Roof-like needs smaller eps to avoid "neighbor acne"
  const EPS_SUN  = isRoofLike ? 0.005 : 0.02;  // 5mm roof, 2cm waves
  const MIN_DIST = isRoofLike ? 0.01  : 0.02;  // 1cm roof, 2cm waves

  const origin  = new THREE.Vector3();
  const dirToSun = new THREE.Vector3();
  const pLocal  = new THREE.Vector3();
  const pWorld  = new THREE.Vector3();

  function isSelfOrDescendant(obj, root) {
    let o = obj;
    while (o) {
      if (o === root) return true;
      o = o.parent;
    }
    return false;
  }

  function isBlocked(hits, receiverPanel) {
    if (!hits || hits.length === 0) return false;

    // Ignore self hits on the receiver's own occluder (pvOcc for waves, pvFace for roof-like)
    const receiverOcc = (!isRoofLike)
      ? (receiverPanel?.getObjectByName?.("pvOcc") || null)
      : (receiverPanel?.getObjectByName?.("pvFace") || null);

    for (let i = 0; i < hits.length; i++) {
      const h = hits[i];
      if (!h || !h.object) continue;

      if (typeof h.distance === "number" && h.distance < MIN_DIST) continue;

      const obj = h.object;
      if (obj.isMesh !== true) continue;

      // Self-ignore
      if (receiverOcc && (obj === receiverOcc || isSelfOrDescendant(obj, receiverOcc))) continue;

      // Ignore anything inside the receiver panel assembly
      if (receiverPanel && isSelfOrDescendant(obj, receiverPanel)) continue;

      if (window.__pvBypassFilters === true) return true;

      return true;
    }
    return false;
  }

  // Authoritative app sun vector (scene -> sun)
  if (window.__sunDirToSun) dirToSun.copy(window.__sunDirToSun).normalize();
  else if (typeof sunLight !== "undefined" && sunLight) sunLight.getWorldDirection(dirToSun).negate().normalize();
  else return 1.0;

  // Optional deterministic capture
  const CAP = (window.__pvCapture && window.__pvCapture.enabled) ? window.__pvCapture : null;
  if (CAP) {
    CAP.rays = Array.isArray(CAP.rays) ? CAP.rays : [];
    CAP.limit = typeof CAP.limit === "number" ? CAP.limit : 30;
  }

  let total = 0;
  let lit = 0;
  let blockedCount = 0;

  for (let pi = 0; pi < window.panelMeshes.length; pi++) {
    const panel = window.panelMeshes[pi];
    if (!panel) continue;

    // Sample on pvFace always (works for both waves + roof-like)
    const pvFace = panel.getObjectByName?.("pvFace");
    if (!pvFace || !pvFace.isMesh || !pvFace.geometry) continue;

    pvFace.updateMatrixWorld?.(true);

    const g = pvFace.geometry;
    if (!g.boundingBox) g.computeBoundingBox();
    const bb = g.boundingBox;
    if (!bb) continue;

    // pvFace is PlaneGeometry in local XY; sample on XY and let transforms handle orientation
    const minX = bb.min.x, maxX = bb.max.x;
    const minY = bb.min.y, maxY = bb.max.y;

    for (let ix = 0; ix < nx; ix++) {
      const fx = (ix + 0.5) / nx;
      const x = minX + (maxX - minX) * fx;

      for (let iy = 0; iy < ny; iy++) {
        const fy = (iy + 0.5) / ny;
        const y = minY + (maxY - minY) * fy;

        pLocal.set(x, y, 0);
        pWorld.copy(pLocal);
        pvFace.localToWorld(pWorld);

        total++;

        // Always push slightly toward sun (single global convention)
        origin.copy(pWorld).addScaledVector(dirToSun, EPS_SUN);

        raycaster.near = MIN_DIST;
        raycaster.set(origin, dirToSun);

        const hits = raycaster.intersectObjects(occluders, true);
        const blocked = isBlocked(hits, panel);

        if (blocked) blockedCount++;
        else lit++;

        if (CAP && CAP.rays.length < CAP.limit) {
          CAP.rays.push({
            panelIndex: pi,
            origin: origin.toArray(),
            dir: dirToSun.toArray(),
            hits: hits?.length || 0,
            firstDist: hits?.[0]?.distance ?? null,
            firstName: hits?.[0]?.object?.name ?? null,
            firstPanel: hits?.[0]?.object?.userData?.parentPanelUuid ?? null,
            mode: isRoofLike ? "roofLike(pvFace)" : "waves(pvOcc)"
          });
        }
      }
    }
  }

  const tau_shadow = total ? (1 - blockedCount / total) : 1.0;

  // IMPORTANT: output should represent PURE shading mask.
  // Do not compute incidence-weighted beam here; base energy already uses GTI/POA.
  window.__pvLastFacing = {
    total,
    lit,
    blocked: blockedCount,
    tau_shadow,
    k_beam: 1.0,
    // leave f_beam undefined so downstream can’t accidentally prefer it
    f_beam: undefined,
    mode: isRoofLike ? "roofLike(pvFace)" : "waves(pvOcc)"
  };

  if (CAP && CAP.dump) {
    console.log("[PV] mode", window.__pvLastFacing.mode, "dirToSun", dirToSun.toArray(), "tau", tau_shadow);
  }

  return tau_shadow;
}

// Debug: set a known sun and probe panel normals / ndotS
window.__pvTestSun = async function(azDeg = 0, elDeg = 60) {
  setSunDirectionFromAzEl(azDeg, elDeg);
  await nextFrame();
  console.log("[PVTEST] sun", { azDeg, elDeg, dirToSun: window.__sunDirToSun?.toArray?.() });
};

window.__pvProbePanelNDotS = function(panelIndex = 0) {
  const p = (window.panelMeshes && window.panelMeshes[panelIndex]) || null;
  if (!p) return console.warn("[PVTEST] no panelMeshes");
  const q = new THREE.Quaternion();
  p.getWorldQuaternion(q);
  // Use the SAME local normal convention as computePvTransmittanceRaycast (local +Y).
  const n = new THREE.Vector3(0,1,0).applyQuaternion(q).normalize();
  const s = (window.__sunDirToSun ? window.__sunDirToSun.clone().normalize() : null);
  if (!s) return console.warn("[PVTEST] no __sunDirToSun");
  console.log("[PVTEST] panel", { panelIndex, n: n.toArray(), s: s.toArray(), ndotS: n.dot(s) });
};


async function buildPvShadingSamplesRaycast({ year, lat, lon, mode = "interactive" }) {
  const samples = [];
  if (!panelMeshes || panelMeshes.length === 0) return samples;

  const savedAz = lastSunAzDeg;
  const savedEl = lastSunElDeg;

  const nx = (mode === "final") ? 6 : 3;
  const ny = (mode === "final") ? 10 : 5;
  const day = 15;

  // sample hours around (approx) solar noon to reduce knife-edge shading
  const HR_OFFSETS = [-2, 0, +2];

  for (let m = 1; m <= 12; m++) {
    const dim = daysInMonthUTC(year, m);
    const hrNoon = approxSolarNoonUtcHourFromLon(lon);
    const weightHoursPerSample = dim * 24.0;

    let tauShadowAcc = 0;
    let fBeamAcc = 0;
    let nAcc = 0;

    // We'll store the "representative" timestamp as the noon sample time (for display/debug)
    const hrRep = hrNoon;
    const time_utc = isoUtcNoZ(year, m, day, hrRep);

    for (const dhr of HR_OFFSETS) {
      const hr = hrNoon + dhr;

      // Keep Date.UTC happy if hr spills outside [0,23]
      const t = new Date(Date.UTC(year, m - 1, day, hr, 0, 0));

      const sp = solarPositionApproxUTC(t, Number(lat), Number(lon));
      const elRad = (Math.PI / 2) - sp.zenRad;
      if (!Number.isFinite(elRad) || elRad <= 0.01) continue;

      // Normalize azimuth to app convention: 0=N, 90=E, 180=S, 270=W.
      // Many solar position formulas output azimuth as:
      //   0 = South, +West (or 0 = North, +East) depending on implementation.
      // We treat solarPositionApproxUTC().azRad as "0=South, +West" (common),
      // and convert to "0=North, +East":
      //   az_app = (az_south_west + 180) % 360  then flip handedness to +East:
      // If your azimuth is already 0=N,+E, this mapping will look wrong; see debug flag below.
      let azDeg = sp.azRad * 180 / Math.PI;
      azDeg = (azDeg + 180) % 360;     // South→North reference
      azDeg = (360 - azDeg) % 360;     // West-positive → East-positive
      const elDeg = elRad * 180 / Math.PI;

      if (window.__PV_AZ_DEBUG_ONCE !== true) {
        window.__PV_AZ_DEBUG_ONCE = true;
        console.log("[PV] az raw/normalized", { az_raw: (sp.azRad * 180 / Math.PI), az_norm: azDeg, elDeg });
      }

      setSunDirectionFromAzEl(azDeg, elDeg);
      await nextFrame();

      const tau = computePvTransmittanceRaycast({ nx, ny });
      if (Number.isFinite(tau)) {
        tauShadowAcc += tau;
        const fb = Number(window.__pvLastFacing?.f_beam);
        if (Number.isFinite(fb)) fBeamAcc += fb;
        nAcc += 1;
      }
    }

    if (nAcc <= 0) continue;

    const tauShadowMean = tauShadowAcc / nAcc;
    const fBeamMean = (fBeamAcc > 0 ? (fBeamAcc / nAcc) : tauShadowMean);

    samples.push({
      time_utc,
      // Send ONLY the geometric shading mask as the PV multiplier.
      // Backend prefers f_beam if present, so DO NOT send f_beam here.
      tau: Number(tauShadowMean),
      tau_shadow: Number(tauShadowMean),
      weight_hours: weightHoursPerSample
    });

  }

  // Restore previous sun (so interactive view doesn't jump after sampling)
  if (Number.isFinite(savedAz) && Number.isFinite(savedEl)) {
    setSunDirectionFromAzEl(savedAz, savedEl);
    await nextFrame();
    // If you use GPU beam preview elsewhere, keep this
    if (typeof computeBeamTransmittanceGPU === "function") {
      computeBeamTransmittanceGPU();
    }
  }

  return samples;
}


window.buildPvShadingSamplesRaycast = buildPvShadingSamplesRaycast;
window.computePvTransmittanceRaycast = computePvTransmittanceRaycast;
window.setSunDirectionFromAzEl = setSunDirectionFromAzEl;

window.__pvTauAt = async (azDeg, elDeg, nx = 2, ny = 2) => {
  window.setSunDirectionFromAzEl(azDeg, elDeg);
  await nextFrame();
  return window.computePvTransmittanceRaycast({ nx, ny });
};

window.setSunDirectionFromAzEl = setSunDirectionFromAzEl;
window.__pvTauAt = async (azDeg, elDeg, nx = 2, ny = 2) => {
  window.setSunDirectionFromAzEl(azDeg, elDeg);
  await nextFrame();
  return window.computePvTransmittanceRaycast({ nx, ny });
};

window.__pvDebugHit = async (azDeg, elDeg) => {
  // Set sun
  window.setSunDirectionFromAzEl(azDeg, elDeg);
  await nextFrame();

  const panel = (window.panelMeshes && window.panelMeshes[0]) ? window.panelMeshes[0] : null;
  if (!panel) return { error: "no panelMeshes[0]" };

  // Build occluders from your current collector
  const occluders = window._collectPvOccluders ? window._collectPvOccluders() : [];
  const selfFace = panel.getObjectByName ? panel.getObjectByName("pvFace") : null;
  const occludersNoSelf = occluders.filter(o => o !== selfFace);

  const raycaster = new THREE.Raycaster();
  raycaster.near = 0.001;
  raycaster.far = 2000;

  const dirToSun = new THREE.Vector3();
  const origin = new THREE.Vector3();

  // Use EXACTLY the same direction source as computePvTransmittanceRaycast
  if (window.__sunDirToSun) {
    dirToSun.copy(window.__sunDirToSun).normalize();
  } else {
    // fallback if cache isn't set for some reason
    sunLight.getWorldDirection(dirToSun);
    // DirectionalLight direction is the direction the light points (sun → scene).
    // For raycasting blockers we want scene → sun, so negate.
    dirToSun.negate().normalize();
  } 

  // Ray from center of first panel (offset slightly along the ray to avoid self/coplanar hits)
  panel.getWorldPosition(origin);
  origin.addScaledVector(dirToSun, 0.05);

  raycaster.set(origin, dirToSun);

  // Use recursive raycasting to match the main raycaster behavior,
  // but FILTER out outline helpers (LineSegments/EdgesGeometry) so they don't masquerade as blockers.
  const hitsRaw = raycaster.intersectObjects(occludersNoSelf, true);

  const hits = (hitsRaw || []).filter(h => {
    const o = h && h.object;
    if (!o) return false;
    if (o.isMesh !== true) return false;                 // ignores Line/LineSegments
    if (o.type === "LineSegments" || o.isLineSegments) return false;
    const g = o.geometry;
    if (g && g.type === "EdgesGeometry") return false;
    return true;
  });

  const dists = hits.length
    ? hits.map(h => h.distance).filter(Number.isFinite).sort((a,b)=>a-b)
    : [];

  const minDist = dists.length ? dists[0] : null;
  const p50Dist = dists.length ? dists[Math.floor(dists.length * 0.5)] : null;
  const p10Dist = dists.length ? dists[Math.floor(dists.length * 0.1)] : null;
  const p90Dist = dists.length ? dists[Math.floor(dists.length * 0.9)] : null;

  const top = hits.length ? hits.slice(0, 8).map(h => ({
    dist: h.distance,
    type: h.object?.type,
    isMesh: !!h.object?.isMesh,
    name: h.object?.name,
    uuid: h.object?.uuid,
    isPvFace: h.object?.userData?._isPvFace,
    hasFace: !!h.face,
    faceIndex: h.faceIndex
  })) : [];

  return {
    azDeg,
    elDeg,
    sunDir: dirToSun.toArray(),
    occluders: occluders.length,
    hits_raw: hitsRaw ? hitsRaw.length : 0,
    hits: hits.length,
    minDist,
    p10Dist,
    p50Dist,
    p90Dist,
    top
    };
};


      // ============================================================
      // Step 5: Diffuse shading via Sky View Factor (SVF)
      // ============================================================
      // SVF estimates the fraction of visible sky from the water plane under the array.
      // We compute it once per stable configuration using deterministic hemisphere directions
      // (Hammersley sequence, base-2 VDC). This makes it reproducible for audit packs.
      const _svfCache = new Map(); // key -> { svf, n, scheme }
      const SVF_SCHEME = "hammersley_vdc2_uniform_hemisphere";

      function _radicalInverseVdC(i) {
        // base-2 Van der Corput
        let x = i >>> 0;
        let inv = 0;
        let denom = 1;
        while (x) {
          denom *= 2;
          inv = inv * 2 + (x & 1);
          x >>>= 1;
        }
        return denom > 1 ? inv / denom : 0;
      }

      function _hammersley2D(i, n) {
        return [ (i + 0.5) / n, _radicalInverseVdC(i) ];
      }

      function _dirFromHemisphereUV(u, v) {
        // Uniform over hemisphere solid angle:
        // phi in [0,2pi), cos(theta) in [0,1]
        const phi = 2 * Math.PI * u;
        const cosT = 1.0 - v; // v uniform => cosT uniform
        const sinT = Math.sqrt(Math.max(0, 1 - cosT * cosT));
        return new THREE.Vector3(
          Math.cos(phi) * sinT,
          cosT,
          Math.sin(phi) * sinT
        );
      }

      function _collectOccluders() {
        const occluders = [];
        if (!arrayGroup) return occluders;

        arrayGroup.traverse(obj => {
          if (!obj || !obj.isMesh) return;

          // Exclude surface / helper meshes from SVF occlusion
          if (obj === groundMesh) return;
          if (obj.userData && (obj.userData._svfIgnore || obj.userData._isSurfacePlane || obj.userData._isShadowHelper)) return;
          if (obj.name && /groundmesh|watershadowmesh|shadowoverlaymesh/i.test(obj.name)) return;

          // Skip fully transparent / non-rendering meshes (common for debug helpers)
     const mat = obj.material;
     // NOTE: pvFace is intentionally transparent with opacity=0; keep it raycastable.

          occluders.push(obj);
        });

        return occluders;
      }

      function _svfCacheKey(nRays) {
        const type = arrayTypeEl.value === "roof" ? "roof" : "waves";
        const az = clampAzimuth(parseInt(azimuthEl.value || "180", 10));
        const elev = parseFloat(elevationEl.value || "0.6");
        const tilt = type === "waves" ? 12.5 : parseFloat(roofTiltEl.value || "15");
        const totalPanels = getCurrentTotalPanels();
        // For roof arrays include rows/cols; for waves include panels per row.
        const extra = (type === "roof")
          ? ("r" + (roofRowsEl.value || "") + "_c" + (roofColsEl.value || ""))
          : ("ppr" + (wavesPanelsPerRowEl.value || ""));
        const surface = (surfaceTypeEl && surfaceTypeEl.value) ? surfaceTypeEl.value : "ground";
        // Include surface sizing inputs so SVF cache doesn't reuse values across water-width changes.
        const wWidth = (surface === "water") ? (parseFloat((waterWidthEl && waterWidthEl.value) ? waterWidthEl.value : (waterWidthM || 0)) || 0) : 0;
        const sX = (typeof currentSurfaceSizeX === "number") ? currentSurfaceSizeX : 0;
        const sZ = (typeof currentSurfaceSizeZ === "number") ? currentSurfaceSizeZ : 0;
        return [type, surface, az.toFixed(2), tilt.toFixed(2), elev.toFixed(2), totalPanels, extra, "ww"+wWidth.toFixed(2), "sx"+sX.toFixed(2), "sz"+sZ.toFixed(2), nRays, SVF_SCHEME].join("|");
      }

      window.__SVF_DEBUG = window.__SVF_DEBUG || false;
      window.__svfLast = window.__svfLast || null;

      window.__SIZE_DEBUG = window.__SIZE_DEBUG || false;
      window.__SIZE_DEBUG_EVERY_UPDATE = window.__SIZE_DEBUG_EVERY_UPDATE || false;

function computeSVFCPU(nRays = 64, gridN = 3) {
        if (!scene) return 1.0;

        const key = _svfCacheKey(nRays) + "|g" + (gridN|0);
        const cached = _svfCache.get(key);
        if (cached && Number.isFinite(cached.svf)) return cached.svf;
        // Prevent recursive simulation triggering during SVF computation
        if (window.__svfComputing) {
          return window.__svfLast?.svf ?? 1.0;
        }
        window.__svfComputing = true;

        // For SVF, use PV occluders only (avoids accidental large planes/overlays)
        const occluders = (window._collectPvOccluders ? window._collectPvOccluders() : _collectOccluders());
        const occludersFiltered = (occluders || []).filter(o =>
          o &&
          o.visible !== false &&
          !(o.userData && o.userData._svfIgnore)
        );

        // Determine sampling bounds: use current surface size (water or ground) if available.
        const sizeX = (typeof currentSurfaceSizeX === "number" && currentSurfaceSizeX > 0) ? currentSurfaceSizeX : 0;
        const sizeZ = (typeof currentSurfaceSizeZ === "number" && currentSurfaceSizeZ > 0) ? currentSurfaceSizeZ : 0;

        // Ray origins: center of ARRAY footprint (exclude surface plane / overlays) projected to surface plane (y ~= 0).
        const _vis = [];
        try {
        if (groundMesh) { _vis.push([groundMesh, groundMesh.visible]); groundMesh.visible = false; }
        if (waterShadowMesh) { _vis.push([waterShadowMesh, waterShadowMesh.visible]); waterShadowMesh.visible = false; }
        if (shadowOverlayMesh) { _vis.push([shadowOverlayMesh, shadowOverlayMesh.visible]); shadowOverlayMesh.visible = false; }

        // Prefer sampling over the ACTIVE surface plane (ground/water), not arrayGroup bbox.
        // This avoids SVF being "stuck" at certain azimuths due to bbox/coverage artifacts.

        let box;
        let c = new THREE.Vector3();
        let ySurface = 0.0;

        // In this project, groundMesh is the active surface plane
        const surfaceMesh = (groundMesh || null);

        if (surfaceMesh) {
          box = new THREE.Box3().setFromObject(surfaceMesh);
          box.getCenter(c);

          const wp = new THREE.Vector3();
          surfaceMesh.getWorldPosition(wp);
          ySurface = wp.y;
        } else {
          // Fallback to arrayGroup bbox
          box = new THREE.Box3().setFromObject(arrayGroup);
          box.getCenter(c);
          ySurface = 0.0;
        }


        // restore visibility
        for (const [o,v] of _vis) o.visible = v;

        // If surface size isn't known, fall back to bbox extents (still excluding plane)
        const ext = box.getSize(new THREE.Vector3());
        const sx = (sizeX > 0) ? sizeX : Math.max(0.1, ext.x);
        const sz = (sizeZ > 0) ? sizeZ : Math.max(0.1, ext.z);

        const raycaster = new THREE.Raycaster();
        raycaster.far = 1e6;
        raycaster.near = 0.001;

        // Sample points on an N x N grid over the surface plane area (centered on c.x,c.z)
        const N = Math.max(1, Math.min(9, gridN|0));

        // Use fractional positions avoiding exact edges (more stable)
        const frac = [];
        if (N === 1) {
          frac.push(0.0);
        } else {
          for (let i = 0; i < N; i++) {
            // map to [-0.4, 0.4] inclusive
            const t = (i / (N - 1)) * 0.8 - 0.4;
            frac.push(t);
          }
        }

        let svfSum = 0;
        let nSamples = 0;

        for (let ix = 0; ix < frac.length; ix++) {
          for (let iz = 0; iz < frac.length; iz++) {
            const ox = frac[ix] * (sx * 0.5);
            const oz = frac[iz] * (sz * 0.5);
            const ORIGIN_Y = ySurface + 0.05;
            const origin = new THREE.Vector3(c.x + ox, ORIGIN_Y, c.z + oz);



            let visible = 0;

            let hitsTotal = 0;
            for (let i = 0; i < nRays; i++) {
              const hv = _hammersley2D(i, nRays);
              const dirLocal = _dirFromHemisphereUV(hv[0], hv[1]).normalize();
              raycaster.set(origin, dirLocal);
              const hits = raycaster.intersectObjects(occludersFiltered, true);
              if (!hits || hits.length === 0) {
                visible++;
              } else {
                hitsTotal++;
              }
              if (window.__SVF_DEBUG && ix === 0 && iz === 0 && i < 8) {
                const d = (hits && hits.length) ? hits[0].distance : null;
                console.log("[SVF] ray", i, "hit?", !!(hits && hits.length), "dist", d);
              }
            }

            const svfPt = Math.max(0, Math.min(1, visible / Math.max(1, nRays)));
            if (window.__SVF_DEBUG) {
              console.log("[SVF] sample", nSamples, "origin", {x: origin.x, y: origin.y, z: origin.z}, "misses", visible, "hits", hitsTotal, "svfPt", svfPt);
            }
            svfSum += svfPt;
            nSamples++;
          }
        }

        const svf = Math.max(0, Math.min(1, svfSum / Math.max(1, nSamples)));
        _svfCache.set(key, { svf, n: nRays, scheme: SVF_SCHEME, n_samples: nSamples });

        if (window.__SVF_DEBUG) {
          window.__svfLast = { svf, nRays, nSamples, scheme: SVF_SCHEME, center: c.clone(), surfaceSize: { x: sx, z: sz } };
        }
        window.__svfLast = { svf };

        return svf;

      } finally {
        for (let i = 0; i < _vis.length; i++) {
          const m = _vis[i][0], v = _vis[i][1];
          if (m) m.visible = v;
        }
        window.__svfComputing = false;
      }
}


      window.__svfDebugOnce = function __svfDebugOnce(nRays = 64) {
        if (!scene) return { error: "no scene" };

        // Occluders: match computeSVFCPU
        const occluders = (window._collectPvOccluders ? window._collectPvOccluders() : _collectOccluders());
        const occludersFiltered = (occluders || []).filter(o =>
          o &&
          o.visible !== false &&
          !(o.userData && o.userData._svfIgnore)
        );

        // Hide planes/overlays exactly like computeSVFCPU does
        const _vis = [];
        if (groundMesh) { _vis.push([groundMesh, groundMesh.visible]); groundMesh.visible = false; }
        if (waterShadowMesh) { _vis.push([waterShadowMesh, waterShadowMesh.visible]); waterShadowMesh.visible = false; }
        if (shadowOverlayMesh) { _vis.push([shadowOverlayMesh, shadowOverlayMesh.visible]); shadowOverlayMesh.visible = false; }

        // Determine origin like computeSVFCPU
        let box;
        const c = new THREE.Vector3();
        let ySurface = 0.0;

        // Prefer active surface plane center when possible
        const surfaceType = (typeof surfaceTypeEl !== "undefined" && surfaceTypeEl) ? surfaceTypeEl.value : "ground";
        const surfaceMesh = (surfaceType === "water")
          ? ((typeof waterMesh !== "undefined" && waterMesh) ? waterMesh : null)
          : ((typeof groundMesh !== "undefined" && groundMesh) ? groundMesh : null);

        try {
          if (surfaceMesh) {
            box = new THREE.Box3().setFromObject(surfaceMesh);
            box.getCenter(c);
            const wp = new THREE.Vector3();
            surfaceMesh.getWorldPosition(wp);
            ySurface = wp.y;
          } else {
            box = new THREE.Box3().setFromObject(arrayGroup);
            box.getCenter(c);
            ySurface = 0.0;
          }
        } finally {
          // Restore visibility
          for (const [o, v] of _vis) o.visible = v;
        }

        const origin = new THREE.Vector3(c.x, ySurface + 0.05, c.z);

        const raycaster = new THREE.Raycaster();
        raycaster.near = 0.001;
        raycaster.far = 1e6;

        let total = 0, hitAny = 0, missAny = 0;
        const sampleHits = [];
        const sampleMisses = [];

        // Use the SAME hemisphere sampling helpers if they exist
        const hasHammersley = (typeof _hammersley2D === "function" && typeof _dirFromHemisphereUV === "function");

        for (let i = 0; i < nRays; i++) {
          let dir;
          if (hasHammersley) {
            const hv = _hammersley2D(i, nRays);
            dir = _dirFromHemisphereUV(hv[0], hv[1]).normalize();
          } else {
            // fallback (deterministic-ish)
            const u = (i + 0.5) / nRays;
            const v = (i * 0.61803398875) % 1;
            dir = _dirFromHemisphereUV ? _dirFromHemisphereUV(u, v).normalize() : new THREE.Vector3(0, 1, 0);
          }

          raycaster.set(origin, dir);
          const hits = raycaster.intersectObjects(occludersFiltered, true);

          total++;
          if (hits && hits.length) {
            hitAny++;
            if (sampleHits.length < 8) {
              const h = hits[0];
              sampleHits.push({
                dist: h.distance,
                name: h.object?.name,
                uuid: h.object?.uuid
              });
            }
          } else {
            missAny++;
            if (sampleMisses.length < 4) {
              sampleMisses.push({ dir: dir.toArray() });
            }
          }
        }

        const hitFrac = total ? (hitAny / total) : null;
        const missFrac = total ? (missAny / total) : null;

        console.log("[SVF DEBUG ONCE]", {
          surfaceType,
          origin: { x: origin.x, y: origin.y, z: origin.z },
          occluders: occludersFiltered.length,
          hitFrac,
          missFrac,
          sampleHits,
          sampleMisses
        });

        return {
          surfaceType,
          origin: origin.toArray(),
          occluders: occludersFiltered.length,
          hitFrac,
          missFrac,
          sampleHits,
          sampleMisses
        };
      };

      // Expose for debugging in console
      window.computeSVFCPU = computeSVFCPU;


      // NOAA-style solar position approximation (UTC), matching backend convention:
      // returns { zenRad, azRad } where az: 0=N,90=E,180=S,270=W
      function solarPositionApproxUTC(tUtc, latDeg, lonDeg) {
        const toRad = (d) => d * Math.PI / 180;

        const yearStart = Date.UTC(tUtc.getUTCFullYear(), 0, 1);
        const doy = Math.floor((tUtc.getTime() - yearStart) / 86400000) + 1;

        const fracHour = tUtc.getUTCHours() + tUtc.getUTCMinutes() / 60 + tUtc.getUTCSeconds() / 3600;

        const gamma = 2 * Math.PI / 365 * (doy - 1 + (fracHour - 12) / 24);

        const eot = 229.18 * (
          0.000075 +
          0.001868 * Math.cos(gamma) -
          0.032077 * Math.sin(gamma) -
          0.014615 * Math.cos(2 * gamma) -
          0.040849 * Math.sin(2 * gamma)
        );

        const decl =
          0.006918 -
          0.399912 * Math.cos(gamma) +
          0.070257 * Math.sin(gamma) -
          0.006758 * Math.cos(2 * gamma) +
          0.000907 * Math.sin(2 * gamma) -
          0.002697 * Math.cos(3 * gamma) +
          0.00148 * Math.sin(3 * gamma);

        const minutesUTC = fracHour * 60;
        const tst = (minutesUTC + eot + 4 * lonDeg) % 1440;

        const haDeg = tst / 4 - 180;
        const ha = toRad(haDeg);

        const lat = toRad(latDeg);

        let cosZen = Math.sin(lat) * Math.sin(decl) + Math.cos(lat) * Math.cos(decl) * Math.cos(ha);
        cosZen = Math.max(-1, Math.min(1, cosZen));
        const zen = Math.acos(cosZen);

        const sinAz = -Math.sin(ha) * Math.cos(decl) / Math.max(1e-9, Math.sin(zen));
        const cosAz = (Math.sin(decl) - Math.sin(lat) * Math.cos(zen)) / (Math.cos(lat) * Math.max(1e-9, Math.sin(zen)));
        let az = Math.atan2(sinAz, cosAz);
        if (az < 0) az += 2 * Math.PI;

        return { zenRad: zen, azRad: az };
      }

      // Compute representative beam transmittance samples (no UI changes).
      // This runs fast on a small set of timestamps and updates lastBeamTransmittance.
      function computeRepresentativeTransmittance(mode = "interactive") {
        if (!groundMesh || !sunLight) return;

        const lat = currentLocation ? parseFloat(currentLocation.lat) : 0;
        const lon = currentLocation ? parseFloat(currentLocation.lon) : 0;

        // Choose a representative year/day; equinox is stable
        const year = new Date().getUTCFullYear() - 1;
        const month = 2; // March (0-indexed)
        const day = 20;

        const hours = (mode === "final")
          ? [6, 8, 10, 12, 14, 16, 18]
          : [10, 12, 14];

        let sum = 0;
        let count = 0;

        for (const h of hours) {
          const t = new Date(Date.UTC(year, month, day, h, 0, 0));
          const sp = solarPositionApproxUTC(t, lat, lon);
          const elRad = (Math.PI / 2) - sp.zenRad;
          if (elRad <= 0) continue;

          // Normalize azimuth to app convention: 0=N, 90=E, 180=S, 270=W.
          // Treat solarPositionApproxUTC().azRad as "0=South, +West" (common),
          // convert to "0=North, +East":
          let azDeg = sp.azRad * 180 / Math.PI;
          azDeg = (azDeg + 180) % 360;     // South→North reference
          azDeg = (360 - azDeg) % 360;     // West-positive → East-positive
          const elDeg = elRad * 180 / Math.PI;

          setSunDirectionFromAzEl(azDeg, elDeg);

          // Render once so shadows are up to date
          renderer.render(scene, camera);

          sum += computeBeamTransmittanceGPU();
          count += 1;
        }

        if (count > 0) {
          lastBeamTransmittance = sum / count;
        }

        // For debugging / development visibility only
        // (no UI changes)
        // console.log("Beam transmittance (" + mode + "):", lastBeamTransmittance.toFixed(3));
      }

      
      function createTextSprite(text) {
        const canvas = document.createElement("canvas");
        const size = 256;
        canvas.width = size;
        canvas.height = size;
        const ctx = canvas.getContext("2d");
        ctx.clearRect(0, 0, size, size);
        ctx.fillStyle = "rgba(255,255,255,0.85)";
        ctx.beginPath();
        ctx.arc(size / 2, size / 2, size / 2 - 8, 0, Math.PI * 2);
        ctx.fill();

        ctx.fillStyle = "#1f2430";
        ctx.font = "bold 120px system-ui, -apple-system, Segoe UI, sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(text, size / 2, size / 2 + 4);

        const tex = new THREE.CanvasTexture(canvas);
        tex.needsUpdate = true;

        const mat = new THREE.SpriteMaterial({ map: tex, transparent: true });
        const spr = new THREE.Sprite(mat);
        spr.scale.set(1.6, 1.6, 1.0);
        return spr;
      }

      function rebuildDirectionMarkers(centerX, centerZ, sizeX, sizeZ) {
        if (!SHOW_DIRECTION_MARKERS) {
          // Ensure nothing is shown if disabled
          if (directionGroup) {
            while (directionGroup.children.length) directionGroup.remove(directionGroup.children[0]);
          }
          return;
        }
        if (!directionGroup) return;

        while (directionGroup.children.length) directionGroup.remove(directionGroup.children[0]);

        const y = 0.05; // slightly above ground to avoid z-fighting
        const pad = 1.0;

        // Convention for the ground indicators:
        // North = -Z, South = +Z, East = +X, West = -X
        const north = createTextSprite("N");
        north.position.set(centerX, y, centerZ - sizeZ / 2 + pad);

        const south = createTextSprite("S");
        south.position.set(centerX, y, centerZ + sizeZ / 2 - pad);

        const east = createTextSprite("E");
        east.position.set(centerX + sizeX / 2 - pad, y, centerZ);

        const west = createTextSprite("W");
        west.position.set(centerX - sizeX / 2 + pad, y, centerZ);

        directionGroup.add(north, south, east, west);
      }


      

function makeTextSprite(message, options) {
  const opts = options || {};
  const fontSize = opts.fontSize || 64;
  const padding = opts.padding || 24;

  const canvas = document.createElement("canvas");
  const ctx = canvas.getContext("2d");
  ctx.font = `${fontSize}px Arial`;
  const metrics = ctx.measureText(message);
  const textW = Math.ceil(metrics.width);
  const textH = Math.ceil(fontSize * 1.2);

  canvas.width = textW + padding * 2;
  canvas.height = textH + padding * 2;

  // redraw with correct canvas size
  ctx.font = `${fontSize}px Arial`;
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";

  // transparent background
  ctx.fillStyle = "rgba(0,0,0,0)";
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  ctx.fillStyle = "rgba(15,17,26,0.9)";
  ctx.fillText(message, canvas.width / 2, canvas.height / 2);

  const tex = new THREE.CanvasTexture(canvas);
  tex.needsUpdate = true;

  const mat = new THREE.SpriteMaterial({ map: tex, transparent: true });
  const sprite = new THREE.Sprite(mat);

  const scale = opts.scale || 1.2;
  sprite.scale.set(scale, scale, 1);

  return sprite;
}

function initNorthArrow() {
  if (!scene) return;
  if (northArrowGroup) {
    scene.remove(northArrowGroup);
  }

  northArrowGroup = new THREE.Group();

  // Arrow pointing to world North (North = -Z)
  const dir = new THREE.Vector3(0, 0, -1).normalize();
  const origin = new THREE.Vector3(0, 0.02, 0);
  const length = 3.5;

  const arrow = new THREE.ArrowHelper(dir, origin, length, 0x111111, 0.8, 0.4);
  northArrowGroup.add(arrow);

  const label = makeTextSprite("N", { scale: 1.4 });
  label.position.set(0, 0.8, -length - 0.2);
  northArrowGroup.add(label);

  scene.add(northArrowGroup);
}
      
      // Texture tiling helpers: keeps ground/water from looking stretched when the plane resizes.
      // Adjust these "meters per tile" values to taste.
      const _TEX_TILE_METERS = {
        ground: 6.0, // larger = less repetition
        water: 2.0   // smaller = more repetition (reduces "stretched" look)
      };

      function _applySurfaceTilingForPlane(mesh, sx, sz, surfaceType) {
        if (!mesh || !mesh.material) return;
        const mat = mesh.material;
        const type = (surfaceType || '').toLowerCase();
        const tileM = (type === 'water') ? _TEX_TILE_METERS.water : _TEX_TILE_METERS.ground;

        // PlaneGeometry(sx, sz) rotated -PI/2: U ~ X, V ~ Z.
        const repU = Math.max(1, sx / tileM);
        const repV = Math.max(1, sz / tileM);

        const applyToTex = (tex) => {
          if (!tex) return;
          tex.wrapS = THREE.RepeatWrapping;
          tex.wrapT = THREE.RepeatWrapping;
          tex.repeat.set(repU, repV);
          tex.needsUpdate = true;
        };

        applyToTex(mat.map);
        applyToTex(mat.normalMap);
        applyToTex(mat.roughnessMap);
        applyToTex(mat.metalnessMap);
        applyToTex(mat.aoMap);
      }


// --- Water sizing helper (meters) --------------------------------------------
function getWaterSizeMeters(activeGroup) {
  // Width comes from UI slider (canal width). Length follows the current active array footprint.
  const w = (() => {
    const el = document.getElementById("waterWidth");
    if (el && el.value != null) return parseFloat(el.value);
    // fallback: try any slider that contains waterWidth
    const cand = document.querySelector('input[type="range"][id*="water"][id*="Width"]');
    return cand ? parseFloat(cand.value) : 5.0;
  })();

  const margin = 2.0; // meters extra length beyond array footprint
  let len = 20.0;

  try {
    const THREE = window.THREE;
    const tr = window.tiledRoot || window.arrayRoot;
    const g = activeGroup || (
      tr?.getObjectByName?.("wavesGroup") ||
      tr?.getObjectByName?.("roofGroup") ||
      tr?.getObjectByName?.("canopyGroup") ||
      tr
    );
    if (THREE && g) {
      const bb = new THREE.Box3().setFromObject(g);
      const sz = new THREE.Vector3();
      bb.getSize(sz);
      // Choose the larger horizontal extent as "length" direction (in-plan).
      len = Math.max(sz.x, sz.z) + margin * 2.0;
    }
  } catch (e) {
    // keep defaults
  }

  return { x: Math.max(0.5, w), z: Math.max(0.5, len) };
}

// Expose for console debugging
window.getWaterSizeMeters = getWaterSizeMeters;

function updateGroundToArray(marginMeters) {
        if (!groundMesh) return;

        const margin = (typeof marginMeters === "number") ? marginMeters : 5;

        const surface = (surfaceTypeEl && surfaceTypeEl.value) ? String(surfaceTypeEl.value).toLowerCase() : "ground";
        const counts = getGroundTileCounts();

        // Arrays-only object used for footprint measurement (must NOT include groundMesh).
        // IMPORTANT: when ground tiling is active, groundTilingGroup contains ONLY the clones.
        // The base array (wavesGroup/roofGroup) is separate, so bounds must UNION(base + clones).
        const baseArray = (wavesGroup && wavesGroup.visible) ? wavesGroup : roofGroup;
        const tilingActive = (surface === "ground" && groundTilingGroup && ((counts.x > 1) || (counts.y > 1)));
        if (!baseArray) return;

        // We want a stable footprint size/center that does NOT "breathe" with azimuth.
// Approach:
// - Temporarily set the yaw-parent (tiledRoot) yaw to 0 so the footprint is axis-aligned.
// - Measure the arrays-only bounds in that yaw=0 configuration.
// - Convert the measured world-center into yaw-parent LOCAL space *while yaw=0*.
// - Restore yaw; the ground mesh keeps its local position and rotates with the parent.
const yawParent = (typeof tiledRoot !== "undefined" && tiledRoot) ? tiledRoot : (arrayGroup || scene);

const prevYaw = (yawParent && yawParent.rotation) ? yawParent.rotation.y : 0;
const prevGroundVis = groundMesh.visible;
groundMesh.visible = false; // safety: ensure the plane never contaminates footprint bounds

// Some builds also have shadow overlays; hide if present
if (typeof shadowMesh !== "undefined" && shadowMesh) shadowMesh.visible = false;
if (typeof shadowMesh2 !== "undefined" && shadowMesh2) shadowMesh2.visible = false;

if (yawParent && yawParent.rotation) yawParent.rotation.y = 0;

// Ensure matrices are up to date at yaw=0
scene.updateMatrixWorld(true);
yawParent.updateMatrixWorld(true);

// Compute bounds of arrays-only in world space (yaw=0 frame)
const box = new THREE.Box3().setFromObject(baseArray);
if (tilingActive) {
  // Include all clones (but do not double-count groundMesh; it's hidden above)
  try { box.expandByObject(groundTilingGroup); } catch (e) {}
}
if (!isFinite(box.min.x) || !isFinite(box.max.x)) {
  // restore state
  if (yawParent && yawParent.rotation) yawParent.rotation.y = prevYaw;
  groundMesh.visible = prevGroundVis;
  if (typeof shadowMesh !== "undefined" && shadowMesh) shadowMesh.visible = true;
  if (typeof shadowMesh2 !== "undefined" && shadowMesh2) shadowMesh2.visible = true;
  yawParent.updateMatrixWorld(true);
  return;
}

const sizeW = new THREE.Vector3();
const centerW = new THREE.Vector3();
box.getSize(sizeW);
box.getCenter(centerW);

if (window.__SIZE_DEBUG_EVERY_UPDATE) {
  console.log("[SIZE] footprint world size (m)", { x: sizeW.x, y: sizeW.y, z: sizeW.z }, "centerW", { x: centerW.x, y: centerW.y, z: centerW.z }, "surface", surface);
}

window.__lastFootprint = { surface: surface, x: sizeW.x, y: sizeW.y, z: sizeW.z, center: { x: centerW.x, y: centerW.y, z: centerW.z } };

// Convert world center -> yawParent local while yaw=0
const centerL = yawParent.worldToLocal(centerW.clone());

// Restore yaw and visibility
if (yawParent && yawParent.rotation) yawParent.rotation.y = prevYaw;
groundMesh.visible = prevGroundVis;
if (typeof shadowMesh !== "undefined" && shadowMesh) shadowMesh.visible = true;
if (typeof shadowMesh2 !== "undefined" && shadowMesh2) shadowMesh2.visible = true;
scene.updateMatrixWorld(true);
yawParent.updateMatrixWorld(true);

        // Size (constant rim in both directions)
        let sx = Math.max(1.0, sizeW.x + 2 * margin);
        let sz = Math.max(1.0, sizeW.z + 2 * margin);

        // Water mode sizing:
        // - X (width) is ALWAYS the slider value (can be narrower or wider than the array footprint).
        // - Z (length) follows array footprint + symmetric margin (like ground mode).
        if (surface === "water") {
          // Water sizing rule:
          // - The *long* axis of the water plane follows the array footprint + symmetric margin.
          // - The *short* axis is ALWAYS the slider value (can be narrower or wider than the array footprint).
          const v = (typeof waterWidthM === "number" && isFinite(waterWidthM)) ? waterWidthM : 5.0;
          const shortAxis = Math.max(0.01, v);

          // Determine which footprint axis is "long" in the scene (handles canopy being modeled 90° vs waves).
          const longIsX = (sizeW.x >= sizeW.z);

          if (longIsX) {
            // Long axis along X, slider controls Z width
            sx = Math.max(1.0, sizeW.x + 2 * margin);
            sz = shortAxis;
          } else {
            // Long axis along Z, slider controls X width
            sx = shortAxis;
            sz = Math.max(1.0, sizeW.z + 2 * margin);
          }
        }


        // Update cached surface dimensions (used e.g. for water-area reporting to backend)
        currentSurfaceSizeX = sx;
        currentSurfaceSizeZ = sz;
        currentWaterAreaM2 = (surface === "water") ? (sx * sz) : 0;

        if (window.__SIZE_DEBUG_EVERY_UPDATE) {
          console.log("[SIZE] surface plane dims (m)", {
            surface,
            sliderWaterWidthM: (typeof waterWidthM === "number" ? waterWidthM : null),
            longIsX: (surface === "water") ? (sizeW.x >= sizeW.z) : null,
            sx, sz,
            water_area_m2: currentWaterAreaM2,
            footprint_x: sizeW.x,
            footprint_z: sizeW.z,
            margin
          });
        }

        // Place ground mesh at the footprint center in the yaw-parent's local coordinates
        groundMesh.position.set(centerL.x, 0.0, centerL.z);

        // Keep plane rotation purely in XZ (geometry is rotated), yaw comes from parent (tiledRoot).
        groundMesh.rotation.set(-Math.PI / 2, 0, 0);

        // Rebuild geometry to avoid non-uniform scaling artifacts
        const prevGeom = groundMesh.geometry;
        groundMesh.geometry = new THREE.PlaneGeometry(sx, sz);
        if (prevGeom) prevGeom.dispose();

        // Sync shadow sampling plane to ground
        syncShadowPlaneToGround();

        // Place the 3D North arrow just outside the ground plane on world-north (-Z).
        if (northArrowGroup) {
          // Compute arrow position in world using current yaw (prevYaw).
          // Convert ground center to world
          const centerWorldNow = new THREE.Vector3();
          groundMesh.getWorldPosition(centerWorldNow);
          // Extent along world -Z for a yawed rectangle
          const yaw = prevYaw;
          const extentZ = 0.5 * (Math.abs(sx * Math.sin(yaw)) + Math.abs(sz * Math.cos(yaw)));
          northArrowGroup.position.set(centerWorldNow.x, 0.02, centerWorldNow.z - extentZ - 1.0);
        }
      }

      // Format annual water savings in liters per year
      function formatLitersPerYear(litersPerYear) {
        const v = Number(litersPerYear);
        if (!Number.isFinite(v)) return "–";

        const abs = Math.abs(v);

        if (abs >= 1e12) return (v / 1e12).toFixed(2) + " TL per year";
        if (abs >= 1e9)  return (v / 1e9).toFixed(2)  + " GL per year";
        if (abs >= 1e6)  return (v / 1e6).toFixed(2)  + " ML per year";
        if (abs >= 1e3)  return (v / 1e3).toFixed(2)  + " kL per year";

        return v.toFixed(0) + " Liters per year";
      }

      // Format annual energy in MWh
      function formatAnnual(mwh) {
        if (!Number.isFinite(mwh)) return "–";
        return Number(mwh).toFixed(2) + " Megawatt-hour per year";
      }

      function _fmtNumber(n, digits = 0) {
        const x = Number (n);
        if (!Number.isFinite(x)) return "-";
        return x.toLocaleString(undefined, { maximumFractionDigits: digits, minimumFractionDigits: digits });
      }

      function _setText(id, text) {
        const el = document.getElementById(id);
        if (el) el.textContent = text;
      }

      function applySimulationResultsToUI(data) {
        try {
          if (!data || typeof data !== "object") {
            _setText("resultsStatus", "No results returned.");
            return;
          }

          window.__lastSimResponse = data;

          try {
            const totalPanels = getCurrentTotalPanels();
            _setText("metricPanels", Number.isFinite(totalPanels) ? String(totalPanels) : "-");
          } catch (_) {}

          // Annual energy: prefer shaded PV if present, else baseline annual_energy_kwh
            const annualKwh =
              (data?.annual_energy_kwh_shaded_pv != null)
                ? Number(data.annual_energy_kwh_shaded_pv)
                : (data?.annual_energy_kwh != null ? Number(data.annual_energy_kwh) : null);

          if (Number.isFinite(annualKwh)) {
             const mwh = annualKwh / 1000.0;
             _setText("metricAnnual", `${_fmtNumber(mwh, 2)} Megawatt-hour per year`);
           } else {
             _setText("metricAnnual", "–");
           }
          
          const waterSavedLpy = data.water_saved_lpy;
          const waterSavedPct = data.water_saved_pct != null ? Number(data.water_saved_pct) : null;
          if (waterSavedLpy != null && Number.isFinite(Number(waterSavedLpy)) && Number(waterSavedLpy) > 0) {
            _setText("metricWaterSaved", `${_fmtNumber(waterSavedLpy, 0)} Liters per year`);
          } else if (waterSavedPct != null && Number.isFinite(waterSavedPct) && waterSavedPct > 0) {
            _setText("metricWaterSaved", `${_fmtNumber(waterSavedPct, 1)}%`);
          } else {
            _setText("metricWaterSaved", "–");
          }
 
            // Clear error UI on success
            _setText("simError", "");
        } catch (e) {
        console.warn("[UI] applySimulationResultsToUI exception", e);
        _setText("resultsStatus", "UI update error (see console).");
        }
      }

      function estimateWaterSavingsLitersPerYear() {
        try {
          // Fast, intentionally simple estimate based on the report's reduction ratios.
          // We use mean POA (W/m²) as a proxy for annual radiation.
          if (!surfaceTypeEl || surfaceTypeEl.value !== "water") return null;
          if (!currentLocation) return null;
          
          // Approx annual irradiation on a horizontal surface (kWh/m²/year)
          // using mean POA as a proxy. This is coarse but stable and fast.
          const meanPoa = Number.isFinite(lastSimMeanPOA) ? lastSimMeanPOA : null;
          if (meanPoa == null) return null;
          const annualKwhPerM2 = (meanPoa * 8760.0) / 1000.0;
          
          // Convert to MJ/m²/year (1 kWh = 3.6 MJ)
          const R = annualKwhPerM2 * 3.6;
          
          // Radiation-based evaporation model (report section 3.2)
          const K = 0.60;   // empirical coefficient (0.5–0.7)
          const lambda = 2.45; // MJ/kg  (≈ MJ/mm·m²)
          const evapMmPerYear = (K * R) / lambda; // mm/year
          
          // Surface area (m²) – use the fitted surface plane area.
          const surfaceArea = Math.max(1e-6, groundDims.sx * groundDims.sz);
          const baselineLiters = evapMmPerYear * surfaceArea; // 1 mm over 1 m² = 1 L
          
          // Coverage ratio = projected PV area / surface area.
          const metaIdx = parseInt(panelTypeEl.value || "0", 10);
          const meta = panelsMeta[metaIdx] || panelsMeta[0];
          const panelArea = (meta?.width_m || 1.0) * (meta?.height_m || 1.6);
          const totalPanels = getCurrentTotalPanels();
          const type = arrayTypeEl.value === "roof" ? "roof" : "waves";
          const azimuthDeg = clampAzimuth(parseInt(azimuthEl.value || "180", 10));
          const elev = parseFloat(elevationEl.value || "0") || 0;
          
          let tiltDeg = 0;
          if (type === "waves") tiltDeg = 12.5;
          else tiltDeg = parseFloat(roofTiltEl.value || "0") || 0;
          const tiltRad = degToRad(tiltDeg);
          const plusOrientationKey = orientationKeyFromAzTilt(azimuthDeg, tiltDeg);
          const minusOrientationKey = orientationKeyFromAzTilt(azimuthDeg + 180, tiltDeg);
          const projectedPvArea = totalPanels * panelArea * Math.cos(tiltRad);
          const coverage = Math.max(0, Math.min(1, projectedPvArea / surfaceArea));
          
          // Shading-only reductions from the report base simulation (section 3.3)
          // Waves: 52.3% vs uncovered; canopy: 36.3% vs uncovered.
          let reduction = (type === "waves") ? 0.523 : 0.363;
          
          // Optional wind-shield boost for Solar Waves: up to 93.6% at very low elevation
          // (report section 5.2). We interpolate by elevation.
          if (type === "waves") {
          const rLow = 0.936;
          const rHigh = 0.523;
          const t = Math.max(0, Math.min(1, (elev - 1.0) / (5.0 - 1.0))); // 1m..5m
          reduction = rLow + (rHigh - rLow) * t;
          }
          
          // Savings: baseline * coverage * reduction
          return baselineLiters * coverage * reduction;
        } catch (e) {
          return null;
        }
      }

function handleResize() {
        if (!renderer || !camera) return;
        const w = canvasContainer.clientWidth;
        const h = canvasContainer.clientHeight || 1;
        camera.aspect = w / h;
        camera.updateProjectionMatrix();
        renderer.setSize(w, h);
      }

      function animate() {
        requestAnimationFrame(animate);
        if (controls) controls.update();

        // Throttle sun/heatmap updates to avoid excessive work.
        const nowMs = performance.now();
        if (!animate._lastSunUpdateMs || (nowMs - animate._lastSunUpdateMs) > 500) {
          animate._lastSunUpdateMs = nowMs;
          updateRealtimeSunAndHeatmap();
        }

        if (renderer && scene && camera) {
          renderer.render(scene, camera);
        }
        updateHoverTooltip();
      }

      
      function normalizePanelMeta(p) {
        // Accept a few common schemas, including the app's panels.json schema (width_mm/height_mm).
        const num = (v) => {
          const n = Number(v);
          return Number.isFinite(n) ? n : undefined;
        };
        const mmToM = (v) => (Number.isFinite(v) ? v / 1000.0 : undefined);

        // Width
        let width_m =
          Number.isFinite(num(p.width_m)) ? num(p.width_m)
          : Number.isFinite(num(p.width)) ? (num(p.width) > 20 ? num(p.width) / 1000.0 : num(p.width))
          : Number.isFinite(num(p.w)) ? num(p.w)
          : undefined;
        if (!Number.isFinite(width_m)) {
          const wmm = num(p.width_mm);
          if (Number.isFinite(wmm)) width_m = mmToM(wmm);
        }

        // Height (a.k.a. panel length)
        let height_m =
          Number.isFinite(num(p.height_m)) ? num(p.height_m)
          : Number.isFinite(num(p.height)) ? (num(p.height) > 20 ? num(p.height) / 1000.0 : num(p.height))
          : Number.isFinite(num(p.h)) ? num(p.h)
          : undefined;
        if (!Number.isFinite(height_m)) {
          const hmm = num(p.height_mm);
          if (Number.isFinite(hmm)) height_m = mmToM(hmm);
        }

        // Thickness
        let thickness_m =
          Number.isFinite(num(p.thickness_m)) ? num(p.thickness_m)
          : Number.isFinite(num(p.thickness)) ? (num(p.thickness) > 20 ? num(p.thickness) / 1000.0 : num(p.thickness))
          : undefined;
        if (!Number.isFinite(thickness_m)) {
          const tmm = num(p.thickness_mm);
          if (Number.isFinite(tmm)) thickness_m = mmToM(tmm);
        }

        // Power at STC (W)
        const rated_power_w =
          Number.isFinite(num(p.rated_power_w)) ? num(p.rated_power_w)
          : Number.isFinite(num(p.pmp_w)) ? num(p.pmp_w)
          : Number.isFinite(num(p.power_w)) ? num(p.power_w)
          : Number.isFinite(num(p.rated_power)) ? num(p.rated_power)
          : undefined;

        // NOCT (°C)
        const noct =
          Number.isFinite(num(p.noct)) ? num(p.noct)
          : Number.isFinite(num(p.noct_c)) ? num(p.noct_c)
          : Number.isFinite(num(p.NOCT)) ? num(p.NOCT)
          : undefined;

        // Temperature coefficient at Pmp (per °C, negative). Support percent-per-°C.
        let gamma_pmp =
          Number.isFinite(num(p.gamma_pmp)) ? num(p.gamma_pmp)
          : Number.isFinite(num(p.temp_coeff)) ? num(p.temp_coeff)
          : Number.isFinite(num(p.gamma)) ? num(p.gamma)
          : undefined;
        if (!Number.isFinite(gamma_pmp)) {
          const gpc = num(p.gamma_pmp_percent_per_c);
          if (Number.isFinite(gpc)) gamma_pmp = gpc / 100.0;
        }

        // Optional module efficiency at STC (0..1)
        const eff_stc =
          Number.isFinite(num(p.eff_stc)) ? num(p.eff_stc)
          : undefined;

        return {
          id: p.id ?? p.name ?? "",
          manufacturer: p.manufacturer ?? p.brand ?? "Unknown",
          name: (p.name ?? p.model ?? p.id ?? p.sku ?? "Panel"),
          width_m: width_m,
          height_m: height_m,
          thickness_m: thickness_m,
          rated_power_w: rated_power_w,
          eff_stc: eff_stc,
          noct: noct,
          gamma_pmp: gamma_pmp,
          cooling_offset: p.cooling_offset ?? 0
        };
      }

async function loadPanelsMeta() {
        try {
          // Use relative path so it works under http-server, file://, and subpaths.
          const resp = await fetch("panels.json", { cache: "no-store" });
          if (!resp.ok) throw new Error("HTTP " + resp.status);
          const data = await resp.json();

          panelsMeta = Array.isArray(data) ? data : (data && Array.isArray(data.panels) ? data.panels : []);
          panelsMeta = panelsMeta.map(normalizePanelMeta);
          if (!panelsMeta.length) {
            console.warn("panels.json loaded but no panels found; falling back to defaults.");
            panelsMeta = [{ id: "generic-200", name: "Generic 1.0×1.6 m, 200 W", manufacturer: "Generic", width_m: 1.0, height_m: 1.6, thickness_m: 0.035, rated_power_w: 200, noct: 45, gamma_pmp: -0.0035 }];
          }
          // Populate dropdown
          panelTypeEl.innerHTML = "";
          panelsMeta.forEach((p, i) => {
            const opt = document.createElement("option");
            opt.value = String(i);
            opt.textContent = p.name || p.id || `Panel ${i+1}`;
            panelTypeEl.appendChild(opt);
          });

          // Default selection: ASLAN 550W
          try {
            const defIdx = panelsMeta.findIndex(p => {
              const m = String(p.manufacturer || "").toLowerCase();
              const pw = Number(p.rated_power_w);
              return (m.includes("aslan") && pw === 550);
            });
            if (defIdx >= 0) panelTypeEl.value = String(defIdx);
          } catch (_) {}

        } catch (e) {
          console.warn("Failed to load panels.json, using fallback panel library.", e);
          panelsMeta = [{ name: "Generic 1.0×1.6 m, 200 W", width_m: 1.0, height_m: 1.6, thickness_m: 0.035, rated_power_w: 200, noct: 45, gamma_pmp: -0.0035 }];
          panelTypeEl.innerHTML = "";
          const opt = document.createElement("option");
          opt.value = "0";
          opt.textContent = panelsMeta[0].name;
          panelTypeEl.appendChild(opt);
        }

        updatePanelMetaDisplay();
      }

      function updatePanelMetaDisplay() {
        const idx = parseInt(panelTypeEl.value || "0", 10);
        const meta = panelsMeta[idx] || panelsMeta[0];
        if (!meta) return;

        const rated = meta.rated_power_w ? meta.rated_power_w + " W" : "–";
        locationStatusEl.textContent =
          "Size: " + (meta.width_m || "?") + " m × " + (meta.height_m || "?") + " m, Rated: " + rated;
      }

      function updateArrayTypeVisibility() {
        const t = arrayTypeEl.value;
        if (t === "waves") {
          wavesControlsEl.style.display = "block";
          roofControlsEl.style.display = "none";
        } else {
          wavesControlsEl.style.display = "none";
          roofControlsEl.style.display = "block";
        }
      }

      
function clearArrayGroup() {
  panelMeshes.length = 0;

  function disposeChildren(group) {
    if (!group) return;
    while (group.children.length) {
      const obj = group.children.pop();
      obj.traverse?.((n) => {
        if (n.geometry) n.geometry.dispose?.();
        if (n.material) {
          if (Array.isArray(n.material)) n.material.forEach(m => m.dispose?.());
          else n.material.dispose?.();
        }
      });
    }
  }

  disposeChildren(wavesGroup);
  disposeChildren(roofGroup);
  disposeChildren(groundTilingGroup);
}

      /**
       * Solar Waves: bi-facial E–W folds
       * panelTemplate : THREE.Mesh template
       * panelsPerRow  : number of panels along the "wave" (X)
       * azimuthDeg    : array azimuth (deg)
       * elevation     : lowest edge above ground (m)
       *
       * Fixed to 18 folds (rows) to match the original concept.
       */
      function buildWavesArray(panelTemplate, panelsPerRow, azimuthDeg, elevation) {
        // Clear previous children (but keep the group itself)
        while (wavesGroup.children.length > 0) {
          wavesGroup.remove(wavesGroup.children[0]);
        }
        wavesGroup.visible = true;
        roofGroup.visible = false;

        panelMeshes = [];

        const dims = getPanelDimsFromTemplate(panelTemplate);
        const w = dims.w;
        const h = dims.h;

        const colsInt = Math.max(1, Math.floor(panelsPerRow));

        // "Solar Waves" is modeled as repeating pitched bays along +Z.
        // We interpret the fixed 18 rows as 9 pitched bays (2 rows per bay).
        const rowsFixed = 18;
        const bays = Math.max(1, Math.floor(rowsFixed / 2));

        const tiltDeg = 12.5;
        const tiltRad = degToRad(tiltDeg);

        // Projected half-span of one panel along Z
        const proj = h * Math.cos(tiltRad);

        // Ridge height so that the *lowest edge* sits at elevation
        const elev = (elevation || 0.0);
        const ridgeY = elev + h * Math.sin(tiltRad);

        const colSpacing = w;
        const x0 = -0.5 * (colsInt - 1) * colSpacing;

        // Center the bays about Z=0
        const totalLength = bays * (2 * proj);
        const zStart = -0.5 * totalLength;

        for (let b = 0; b < bays; b++) {
          const ridgeZ = zStart + b * (2 * proj) + proj;

          // Two slopes sharing the ridge:
          // - One extends toward +Z (rotate -tilt)
          // - One extends toward -Z (rotate +tilt)
          const slopePlusZ = new THREE.Group();
          slopePlusZ.position.set(0, ridgeY, ridgeZ);
          slopePlusZ.rotation.x = +tiltRad;

          const slopeMinusZ = new THREE.Group();
          slopeMinusZ.position.set(0, ridgeY, ridgeZ);
          slopeMinusZ.rotation.x = -tiltRad;

          for (let ix = 0; ix < colsInt; ix++) {
            const x = x0 + ix * colSpacing;

            const p1 = preparePanelInstance(panelTemplate.clone(true));
            p1.castShadow = true;
            p1.receiveShadow = false;
            p1.position.set(x, 0, +h / 2);
            slopePlusZ.add(p1);
            panelMeshes.push(p1);
            assignOrientationKey(p1, azimuthDeg, tiltDeg);
            p1.userData.tau_beam = 1.0;
            delete p1.userData.snapshot_base_poa_w_m2;

            const p2 = preparePanelInstance(panelTemplate.clone(true));
            p2.castShadow = true;
            p2.receiveShadow = false;
            p2.position.set(x, 0, -h / 2);
            slopeMinusZ.add(p2);
            panelMeshes.push(p2);
            assignOrientationKey(p2, azimuthDeg + 180, tiltDeg);
            p2.userData.tau_beam = 1.0;
            delete p2.userData.snapshot_base_poa_w_m2;
          }

          wavesGroup.add(slopePlusZ);
          wavesGroup.add(slopeMinusZ);
        }

        // Apply global azimuth to the whole wave field
        wavesGroup.position.set(0, 0, 0);
        wavesGroup.rotation.set(0, 0, 0);

        const azDegNorm = clampAzimuth(azimuthDeg);
        const azRad = degToRad(azDegNorm);

        // Convention: 0°=N, 90°=E, 180°=S, 270°=W
        // Base geometry faces +Z, so rotate so 180° faces "South".
        if (tiledRoot) tiledRoot.rotation.y = azRad;
        wavesGroup.rotation.y = 0;
        // Hemisphere mirroring for Solar Waves:
        // The wave fold sequence is authored in a fixed local X direction. In the Southern Hemisphere,
        // mirror along local X so the "leading" fold swaps, matching typical equator-facing intuition.
        if (currentLocation && Number.isFinite(currentLocation.lat)) {
          const wantMirror = currentLocation.lat < 0;
          const sz = Math.abs(wavesGroup.scale.z || 1);
          wavesGroup.scale.z = wantMirror ? -sz : sz;
        }


        dbgFrame("waves", {lat: currentLocation && currentLocation.lat, az: azDegNorm, rotY: wavesGroup.rotation.y, scale: {x:wavesGroup.scale.x,y:wavesGroup.scale.y,z:wavesGroup.scale.z}});
        wavesGroup.updateMatrixWorld(true);
      }


      // Helper – get panel dimensions from BoxGeometry
      function getPanelDimsFromTemplate(panel) {
        const g = panel.geometry && panel.geometry.parameters;
        if (!g) return { w: 1.0, h: 1.6, t: 0.035 };
        // For THREE.BoxGeometry(width, height, depth) used in makePanelTemplateFromMeta:
        return { w: g.width || 1.0, h: g.depth || 1.6, t: g.height || 0.035 };
      }

function _normalizeUVs01(geometry) {
  // Ensure UVs lie in [0..1] *without* introducing tiling.
  // If UVs already span ~[0..1], do nothing.
  // If UVs span [0..N], rescale linearly so the texture stretches once across the surface (1x1).
  if (!geometry || !geometry.attributes || !geometry.attributes.uv) return;
  if (geometry.userData && geometry.userData._uvNormalized01) return;

  const uv = geometry.attributes.uv;
  const EPS = 1e-6;

  let minU = Infinity, maxU = -Infinity, minV = Infinity, maxV = -Infinity;
  for (let i = 0; i < uv.count; i++) {
    const u = uv.getX(i);
    const v = uv.getY(i);
    if (u < minU) minU = u;
    if (u > maxU) maxU = u;
    if (v < minV) minV = v;
    if (v > maxV) maxV = v;
  }

  const spanU = maxU - minU;
  const spanV = maxV - minV;

  // If already 0..1-ish, keep as-is (also preserves BoxGeometry exact 0/1 UVs).
  const needsRescale = (spanU > 1.0 + EPS) || (spanV > 1.0 + EPS) || (minU < -EPS) || (minV < -EPS) || (maxU > 1.0 + EPS) || (maxV > 1.0 + EPS);
  if (!needsRescale) {
    geometry.userData = geometry.userData || {};
    geometry.userData._uvNormalized01 = true;
    return;
  }

  const denomU = spanU > EPS ? spanU : 1.0;
  const denomV = spanV > EPS ? spanV : 1.0;

  for (let i = 0; i < uv.count; i++) {
    const u0 = uv.getX(i);
    const v0 = uv.getY(i);
    const u = (u0 - minU) / denomU;
    const v = (v0 - minV) / denomV;
    uv.setXY(i, u, v);
  }

  uv.needsUpdate = true;
  geometry.userData = geometry.userData || {};
  geometry.userData._uvNormalized01 = true;
}

function makePanelTemplateFromMeta(meta) {
  const w = meta.width_m || 1.0;
  const h = meta.height_m || 1.6;
  const t = meta.thickness_m || 0.035;

  const geom = new THREE.BoxGeometry(w, t, h); // X=width, Y=thickness, Z=height
  _normalizeUVs01(geom);

  const mat  = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.55, metalness: 0.05 });
  const mesh = new THREE.Mesh(geom, mat);
  mesh.castShadow = true;
  mesh.receiveShadow = false;
  mesh.userData.isPanel = true;

  // IMPORTANT: The box body is not the PV-face occluder (avoid box-side artifacts)
  mesh.userData._isPvFace = false;

  const edges = new THREE.EdgesGeometry(geom);
  const line  = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x333333 }));
  line.userData = line.userData || {};
  line.userData._svfIgnore = true;
  line.userData._isOutline = true;
  mesh.add(line);

  // ------------------------------------------------------------
  // Dedicated PV sampling face (pvFace) + thick ray occluder (pvOcc)
  // ------------------------------------------------------------
  if (!geom.boundingBox) geom.computeBoundingBox();
  const bb = geom.boundingBox;

  if (bb) {
    const faceW = bb.max.x - bb.min.x;
    const faceH = bb.max.z - bb.min.z;

    // ---- pvFace: sampling plane (invisible but raycastable)
    const faceGeom = new THREE.PlaneGeometry(faceW, faceH, 1, 1);
    const faceMat  = new THREE.MeshBasicMaterial({
      transparent: true,
      opacity: 0.0,
      depthWrite: false,
      side: THREE.DoubleSide
    });

    const pvFace = new THREE.Mesh(faceGeom, faceMat);
    pvFace.name = "pvFace";
    pvFace.userData = pvFace.userData || {};
    pvFace.userData._isPvFace = true;
    pvFace.userData._svfIgnore = true;
    pvFace.userData._isShadowHelper = true;
    pvFace.userData.parentPanelUuid = mesh.uuid;

    // local +Y panel normal
    pvFace.rotation.x = -Math.PI / 2;
    pvFace.position.y = bb.max.y - 0.001;

    mesh.add(pvFace);

    // ---- pvOcc: thick slab occluder for PV raycasting (invisible but raycastable)
    // Use a small physical thickness so sun rays reliably intersect.
    const pvOccThickness =
      (typeof window !== "undefined" && typeof window.__pvOccThickness === "number")
        ? window.__pvOccThickness
        : 0.03; // meters; tune 0.01–0.04

    const pvOccGeom = new THREE.BoxGeometry(faceW, pvOccThickness, faceH);
    _normalizeUVs01(pvOccGeom);

    const pvOccMat = new THREE.MeshBasicMaterial({
      transparent: true,
      opacity: 0.0,
      depthWrite: false,
      side: THREE.DoubleSide
    });

    const pvOcc = new THREE.Mesh(pvOccGeom, pvOccMat);
    pvOcc.name = "pvOcc";
    pvOcc.userData = pvOcc.userData || {};
    pvOcc.userData._isPvOcc = true;
    pvOcc.userData._svfIgnore = true;          // keep SVF clean unless you explicitly want PV to block SVF
    pvOcc.userData._isShadowHelper = true;
    pvOcc.userData.parentPanelUuid = mesh.uuid;

    // Co-locate and co-orient with pvFace
    pvOcc.position.copy(pvFace.position);
    pvOcc.quaternion.copy(pvFace.quaternion);

    mesh.add(pvOcc);
  }

  return mesh;
}

      function preparePanelInstance(panel) {
        if (!panel) return panel;

        panel.userData.isPanel = true;

        // panel body itself is NOT an occluder
        panel.userData._isPvFace = false;

        panel.traverse(child => {
          // Never store Object3D refs in userData (recursion risk)
          if (child !== panel) {
            child.userData = child.userData || {};
            child.userData.parentPanelUuid = panel.uuid;
            if (child.userData.parentPanel) delete child.userData.parentPanel;
          }

          // IMPORTANT: never store Object3D refs in userData (breaks clone(true))
          if (child !== panel) {
            child.userData = child.userData || {};
            child.userData.parentPanelUuid = panel.uuid;
            // If you previously set parentPanel, ensure it's gone:
            if (child.userData.parentPanel) delete child.userData.parentPanel;
          }

          // ONLY pvFace participates in shading
          if (child.isMesh) {
            child.userData = child.userData || {};
            child.userData._isPvFace = (child.name === "pvFace");
          }
        });

        return panel;
      }

      function assignOrientationKey(mesh, azDeg, tiltDeg) {
        if (!mesh) return;
        mesh.userData.orientationKey = orientationKeyFromAzTilt(azDeg, tiltDeg);
      }

      
      function ensurePanelOrientationKey(mesh) {
        if (!mesh) return;
        if (mesh.userData && mesh.userData.orientationKey) return;

        const azDeg = clampAzimuth(parseInt(azimuthEl.value || "180", 10));
        const type = (arrayTypeEl && arrayTypeEl.value === "roof") ? "roof" : "waves";

        if (type === "roof") {
          const tiltDeg = parseFloat(roofTiltEl.value || "15");
          assignOrientationKey(mesh, azDeg, tiltDeg);
          return;
        }

        // Solar Waves: infer fold side from local Z position (built at +/- h/2)
        const tiltDeg = 12.5;
        const localZ = (mesh.position && Number.isFinite(mesh.position.z)) ? mesh.position.z : 0;
        const sideAz = localZ >= 0 ? azDeg : (azDeg + 180);
        assignOrientationKey(mesh, sideAz, tiltDeg);
      }

/**
       * Solar Roof: simple planar rectangular roof
       * panelTemplate : THREE.Mesh used as a template (has edges as a child)
       * cols, rows    : integer panel counts X/Y
       * tiltDeg       : roof tilt (deg)
       * azimuthDeg    : 0°=N, 90°=E, 180°=S, 270°=W
       * elevation     : lowest edge above ground (m)
       */
      function buildRoofArray(panelTemplate, cols, rows, tiltDeg, azimuthDeg, elevation) {
        // Clear previous children
        while (roofGroup.children.length > 0) {
          roofGroup.remove(roofGroup.children[0]);
        }
        roofGroup.visible = true;
        wavesGroup.visible = false;

        panelMeshes = [];

        const dims = getPanelDimsFromTemplate(panelTemplate);
        const w = dims.w;
        const h = dims.h;

        const colsInt = Math.max(1, Math.floor(cols));
        const rowsInt = Math.max(1, Math.floor(rows));

        // Panels laid out in local X–Z plane, then the whole roofGroup is tilted
        const colSpacing = w;
        const rowSpacing = h;

        const x0 = -0.5 * (colsInt - 1) * colSpacing;
        const z0 = -0.5 * (rowsInt - 1) * rowSpacing;
        const roofOrientationKey = orientationKeyFromAzTilt(azimuthDeg, tiltDeg);

        for (let iz = 0; iz < rowsInt; iz++) {
          for (let ix = 0; ix < colsInt; ix++) {
            const p = preparePanelInstance(panelTemplate.clone(true));
            p.castShadow = true;
            p.receiveShadow = false;
            const x = x0 + ix * colSpacing;
            const z = z0 + iz * rowSpacing;
            p.position.set(x, 0, z);
            roofGroup.add(p);
          
            panelMeshes.push(p);
            assignOrientationKey(p, azimuthDeg, tiltDeg);
            p.userData.tau_beam = 1.0;
            delete p.userData.snapshot_base_poa_w_m2;
}
        }

        // Reset transform then apply tilt + azimuth
        roofGroup.position.set(0, 0, 0);
        roofGroup.rotation.set(0, 0, 0);
        roofGroup.updateMatrixWorld(true);

        const tiltRad = degToRad(tiltDeg || 0.0);
        const azDegNorm = clampAzimuth(azimuthDeg);
        const azRad = degToRad(azDegNorm);

        // Lift so the lowest edge is at the requested elevation
        roofGroup.position.y = (elevation || 0.0) + 0.5 * h * Math.sin(tiltRad);

        // Apply azimuth (yaw around world up) first, then tilt about local X.
        // This makes azimuth a pure spin of the already-tilted plane.
        roofGroup.rotation.set(0, 0, 0);
        // Global azimuth is applied to tiledRoot so tiled arrays rotate together
        if (tiledRoot) tiledRoot.rotation.y = azRad;
        dbgFrame("roof", {lat: currentLocation && currentLocation.lat, az: azDegNorm, rotY: roofGroup.rotation.y});
        roofGroup.rotateX(-tiltRad);

        roofGroup.updateMatrixWorld(true);
      }


      function getGroundTileCounts() {
        const surface = (surfaceTypeEl && surfaceTypeEl.value) ? String(surfaceTypeEl.value).toLowerCase() : "ground";
        if (surface !== "ground") return { x: 1, y: 1 };
        const x = groundArrayXEl ? Math.max(1, Math.floor(parseInt(groundArrayXEl.value || "1", 10))) : 1;
        const y = groundArrayYEl ? Math.max(1, Math.floor(parseInt(groundArrayYEl.value || "1", 10))) : 1;
        return { x, y };
      }

      
      // ============================================================
      // Ground tiling helpers (debug-safe)
      // ============================================================
      
      function clearGroundTilingClones() {
        if (!groundTilingGroup) return;
        while (groundTilingGroup.children.length) {
          const c = groundTilingGroup.children.pop();
          try { groundTilingGroup.remove(c); } catch (e) {}
        }
      }

      function isDescendant(root, target) {
        if (!root || !target) return false;
        let found = false;
        root.traverse((o) => { if (o === target) found = true; });
        return found;
      }

      function getWorldYaw(obj3d) {
        const q = new THREE.Quaternion();
        obj3d.getWorldQuaternion(q);
        const e = new THREE.Euler().setFromQuaternion(q, "YXZ");
        return e.y;
      }

      function projectBoxToYawFrame(worldAABB, yaw) {
        // Project world AABB corners onto yaw-aligned X/Z axes to get footprint sizes.
        const up = new THREE.Vector3(0, 1, 0);
        const xAxis = new THREE.Vector3(1, 0, 0).applyAxisAngle(up, yaw);
        const zAxis = new THREE.Vector3(0, 0, 1).applyAxisAngle(up, yaw);

        const min = worldAABB.min, max = worldAABB.max;
        const corners = [
          new THREE.Vector3(min.x, min.y, min.z),
          new THREE.Vector3(min.x, min.y, max.z),
          new THREE.Vector3(min.x, max.y, min.z),
          new THREE.Vector3(min.x, max.y, max.z),
          new THREE.Vector3(max.x, min.y, min.z),
          new THREE.Vector3(max.x, min.y, max.z),
          new THREE.Vector3(max.x, max.y, min.z),
          new THREE.Vector3(max.x, max.y, max.z),
        ];

        let minX = Infinity, maxX = -Infinity, minZ = Infinity, maxZ = -Infinity;
        for (const c of corners) {
          const px = c.dot(xAxis);
          const pz = c.dot(zAxis);
          minX = Math.min(minX, px); maxX = Math.max(maxX, px);
          minZ = Math.min(minZ, pz); maxZ = Math.max(maxZ, pz);
        }
        return { minX, maxX, minZ, maxZ, sizeX: (maxX - minX), sizeZ: (maxZ - minZ) };
      }

      function yawOffsetToWorld(dx, dz, yaw) {
        // Convert offsets in yaw-frame into world XZ offsets.
        const c = Math.cos(yaw), s = Math.sin(yaw);
        // yaw-frame X points along (cos,0,-sin)?? For our usage in updateGroundToArray the yaw is world yaw.
        // Here we use standard rotation about +Y: (x,z) -> (x*c - z*s, x*s + z*c)
        return { x: dx * c - dz * s, z: dx * s + dz * c };
      }

      

function _safeShallowCloneObject3D(src) {
  // IMPORTANT:
  // THREE.Object3D.clone()/copy() deep-copies userData via JSON.stringify/parse.
  // If userData contains cycles or references to Three objects, that can trigger
  // "too much recursion" (toJSON recursion in three.min.js).
  //
  // This helper clones without invoking THREE's userData JSON serialization.
  if (!src) return null;

  let dst = null;

  // Create same-ish type
  if (src.isGroup) {
    dst = new THREE.Group();
  } else if (src.isMesh) {
    dst = new THREE.Mesh(src.geometry, src.material);
    dst.castShadow = !!src.castShadow;
    dst.receiveShadow = !!src.receiveShadow;
  } else if (src.isLineSegments) {
    dst = new THREE.LineSegments(src.geometry, src.material);
  } else if (src.isLine) {
    dst = new THREE.Line(src.geometry, src.material);
  } else if (src.isPoints) {
    dst = new THREE.Points(src.geometry, src.material);
  } else if (src.isSprite) {
    dst = new THREE.Sprite(src.material);
  } else {
    dst = new THREE.Object3D();
  }

  // Transforms / misc
  dst.name = src.name || "";
  dst.position.copy(src.position);
  dst.quaternion.copy(src.quaternion);
  dst.scale.copy(src.scale);
  dst.visible = src.visible;
  dst.renderOrder = src.renderOrder || 0;
  dst.frustumCulled = (typeof src.frustumCulled === "boolean") ? src.frustumCulled : true;

  // Layers
  try { dst.layers.mask = src.layers.mask; } catch (e) {}

  // userData: shallow copy ONLY (avoid JSON stringify)
  if (src.userData) dst.userData = Object.assign({}, src.userData);

  return dst;
}

function deepCloneWithout(root, shouldSkip) {
  // Defensive clone that NEVER calls Object3D.clone()/copy() to avoid userData JSON recursion.
  if (!root) return null;

  const cloneSelf = _safeShallowCloneObject3D(root);
  if (!cloneSelf) return null;

  for (const ch of (root.children || [])) {
    if (shouldSkip && shouldSkip(ch)) continue;
    const chClone = deepCloneWithout(ch, shouldSkip);
    if (chClone) cloneSelf.add(chClone);
  }
  return cloneSelf;
}

function refreshBaseArrayPrototype() {
  // Build a detached prototype for tiling so clones do not inherit live scene graph links.
  const liveBase = (wavesGroup && wavesGroup.visible) ? wavesGroup : (roofGroup && roofGroup.visible) ? roofGroup : null;
  if (!liveBase) { baseArrayPrototype = null; return; }

  // Ensure tiling container is NOT nested under the live base (can happen after rebuilds).
  if (groundTilingGroup && isDescendant(liveBase, groundTilingGroup)) {
    try { groundTilingGroup.parent && groundTilingGroup.parent.remove(groundTilingGroup); } catch (e) {}
    arrayGroup && tiledRoot.add(groundTilingGroup);
  }

  // Clone without the tiling container or any existing tiled clones.
  baseArrayPrototype = deepCloneWithout(liveBase, (node) => {
    const ud = node && node.userData ? node.userData : null;
    return node === groundTilingGroup || (ud && (ud._isTilingContainer || ud._isTiledClone));
  });
  if (baseArrayPrototype) {
    baseArrayPrototype.name = (liveBase.name || 'base') + '_prototype';
    baseArrayPrototype.visible = true;
  }
}

      // DevTools helper hooks (safe primitives only)
      window.__SW_DEBUG_TILING = {
        last: () => __tilingDebug.last,
        counts: () => ({
          surface: (surfaceTypeEl && surfaceTypeEl.value) ? String(surfaceTypeEl.value).toLowerCase() : "ground",
          x: groundArrayXEl ? Number(groundArrayXEl.value) : 1,
          y: groundArrayYEl ? Number(groundArrayYEl.value) : 1
        }),
        retile: () => { try { applyGroundArrayTiling(); } catch (e) {} },
        clear: () => { try { clearGroundTilingClones(); } catch (e) {} }
      };

function updateGroundTilingVisibility() {
        if (!groundTilingControlsEl) return;
        const surface = (surfaceTypeEl && surfaceTypeEl.value) ? String(surfaceTypeEl.value).toLowerCase() : "ground";
        groundTilingControlsEl.style.display = (surface === "ground") ? "block" : "none";
      }

      function _cloneWithFixedPanelUserData(root) {
        if (!root) return root;

        // Mark this subtree as a tiled clone so we can safely dispose resources when removing it.
        root.userData = root.userData || {};
        root.userData._isTiledCloneRoot = true;

        // Ensure per-panel tooltips and per-panel materials remain independent across clones.
        root.traverse(obj => {
          if (obj && obj.userData && obj.userData.parentPanel) {
            delete obj.userData.parentPanel;
          }
        });

        root.traverse(obj => {
          if (!obj) return;

          // Flag all descendants as belonging to a tiled clone (used for safe disposal).
          obj.userData = obj.userData || {};
          obj.userData._isTiledClone = true;

          if (obj.userData && obj.userData.isPanel) {
            preparePanelInstance(obj);
            ensurePanelOrientationKey(obj);
          }

          if (obj.isMesh) {
            // IMPORTANT: clone geometry + material so disposing clones never affects the base array.
            if (obj.geometry) obj.geometry = obj.geometry.clone();

            if (obj.material) {
              if (Array.isArray(obj.material)) obj.material = obj.material.map(m => (m ? m.clone() : m));
              else obj.material = obj.material.clone();
              obj.material.side = THREE.DoubleSide;
              obj.userData._hasUniqueMat = true;
            }
          }
        });

        return root;
      }


// Clone an Object3D hierarchy but skip any nodes in excludeSet.
// This avoids accidental recursive cloning if a tiling container ends up under the base group.
function _cloneObject3DExcluding(src, excludeSet) {
  if (!src) return null;
  if (excludeSet && excludeSet.has(src)) return null;

  // Shallow clone (no children), we'll manually clone children with exclusions.
  const c = src.clone(false);

  // Preserve userData shallowly (avoid JSON.stringify on Three objects).
  if (src.userData) {
    c.userData = Object.assign({}, src.userData);
  }

  for (const ch of (src.children || [])) {
    if (excludeSet && excludeSet.has(ch)) continue;
    const cc = _cloneObject3DExcluding(ch, excludeSet);
    if (cc) c.add(cc);
  }
  return c;
}


      function applyGroundArrayTiling() {
        if (!arrayGroup || !groundTilingGroup) return;

        const surf = (surfaceTypeEl && surfaceTypeEl.value) ? String(surfaceTypeEl.value).toLowerCase() : "ground";
        const xCopies = groundArrayXEl ? Math.max(1, Math.min(10, parseInt(groundArrayXEl.value || "1", 10))) : 1;
        const yCopies = groundArrayYEl ? Math.max(1, Math.min(10, parseInt(groundArrayYEl.value || "1", 10))) : 1;

        dbgTiling("start", { surface: surf, x: xCopies, y: yCopies, arrayType: (arrayTypeEl ? arrayTypeEl.value : "?") });

        // Guard against re-entrancy (range inputs can fire very rapidly)
        if (applyGroundArrayTiling._busy) {
          dbgTiling("skip (busy)");
          return;
        }
        applyGroundArrayTiling._busy = true;

        try {
          // Enforce hierarchy: tiling group must be a sibling under arrayGroup (never under waves/roof)
          if (groundTilingGroup.parent !== tiledRoot) {
            try { groundTilingGroup.parent && groundTilingGroup.parent.remove(groundTilingGroup); } catch (e) {}
            tiledRoot.add(groundTilingGroup);
          }

          const baseProto = baseArrayPrototype; // detached source
          if (!baseProto) {
            clearGroundTilingClones();
            panelMeshes = basePanelMeshes.slice();
            return;
          }

          // Always clear previous clones (do NOT dispose while debugging to avoid shared-resource issues)
          clearGroundTilingClones();

          // Reset panel list back to the base array before adding clone panels
          panelMeshes = basePanelMeshes.slice();

          if (surf !== "ground" || (xCopies === 1 && yCopies === 1)) {
            dbgTiling("no tiling (surface or counts)");
            // Reset live base array back to origin when not tiling
            try {
              const liveGroup = (wavesGroup && wavesGroup.visible) ? wavesGroup : roofGroup;
              if (liveGroup) { liveGroup.position.x = 0; liveGroup.position.z = 0; }
            } catch (e) {}
            // Ensure any existing ground tiling clones are removed when leaving ground mode
            clearGroundTilingClones();
            panelMeshes = basePanelMeshes.slice();
            return;
          }

          baseProto.updateMatrixWorld(true);

          const yaw = getWorldYaw(baseProto);
          const baseBox = new THREE.Box3().setFromObject(baseProto);
          if (!isFinite(baseBox.min.x) || !isFinite(baseBox.max.x)) {
            dbgTiling("abort: invalid base box");
            return;
          }

          const fp = projectBoxToYawFrame(baseBox, yaw);
          const sizeX = Math.max(0.01, fp.sizeX);
          const sizeZ = Math.max(0.01, fp.sizeZ);
          const stepX = sizeX + ARRAY_TILE_SPACING_M;
          const stepZ = sizeZ + ARRAY_TILE_SPACING_M;

          dbgTiling("footprint", { sizeX, sizeZ, stepX, stepZ, yaw_deg: (yaw * 180 / Math.PI) });

          // Center the *entire* grid around the tiledRoot origin.
// We do this by shifting the live base array (wavesGroup/roofGroup) so that
// the (ix=0, iz=0) cell sits at the negative half-extent, and then placing
// clones at ix/iz steps from that.
const centerXCells = 0.5 * (xCopies - 1);
const centerZCells = 0.5 * (yCopies - 1);

const liveGroup = (wavesGroup && wavesGroup.visible) ? wavesGroup : roofGroup;

// Base cell (0,0) position in local tiledRoot coords (centered layout)
const baseCellX = -centerXCells * stepX;
const baseCellZ = -centerZCells * stepZ;

if (liveGroup) {
  liveGroup.position.x = baseCellX;
  liveGroup.position.z = baseCellZ;
}

let cloneCount = 0;
          let clonePanels = 0;

          for (let ix = 0; ix < xCopies; ix++) {
            for (let iz = 0; iz < yCopies; iz++) {
              if (ix === 0 && iz === 0) continue;

              const clone = deepCloneWithout(baseProto, (node)=>{const ud=node&&node.userData?node.userData:null; return node===groundTilingGroup || (ud && (ud._isTilingContainer||ud._isTiledClone));});
              clone.userData = clone.userData || {};
              clone.userData._isTiledClone = true;
              clone.name = `tiled_${ix}_${iz}`;

              // Place clone in centered grid layout (tiledRoot local).
const dx = baseCellX + ix * stepX;
const dz = baseCellZ + iz * stepZ;

clone.position.x = dx;
clone.position.z = dz;
groundTilingGroup.add(clone);
              cloneCount++;

              clone.traverse((o) => {
                if (o && o.userData && o.userData.isPanel) {
                  o.userData._isClonePanel = true;
                  o.userData._isPvFace = true;
                  panelMeshes.push(o);
                  clonePanels++;
                }
              });
            }
          }

          // Resize ground to fit full tiled footprint (base + clones).
          updateGroundToArray(5);

          dbgTiling("done", { clones: cloneCount, clonePanels, totalPanels: panelMeshes.length });
        } catch (err) {
          const msg = (err && err.message) ? err.message : String(err);
          console.error("[TILING] exception", { message: msg, stack: (err && err.stack) ? String(err.stack).slice(0, 2000) : "" });

          // Leave the scene in a safe state
          try { clearGroundTilingClones(); } catch(e) {}
          try { panelMeshes = basePanelMeshes.slice(); } catch(e) {}

          throw err;
        } finally {
          applyGroundArrayTiling._busy = false;
        }
      }

      function rebuildArrayGeometry() {
  if (!__firstVisualReady) setLoadingStatus("Building solar array…");
  invalidateWaterState("rebuildArrayGeometry");
  if (!arrayGroup) return;
  clearArrayGroup();

  const metaIdx = parseInt(panelTypeEl.value || "0", 10);
  const meta = panelsMeta[metaIdx] || panelsMeta[0];
  if (!meta) return;

  // Build a fresh panel template for this meta
  const panelTemplate = makePanelTemplateFromMeta(meta);
  currentPanelDims = getPanelDimsFromTemplate(panelTemplate);
  // Panel/geometry sanity log (toggle via window.__PANEL_DEBUG = true)
  try {
    if (window.__PANEL_DEBUG || window.__SIZE_DEBUG_EVERY_UPDATE) {
      const w = Number(meta.width_m ?? 1.0);
      const h = Number(meta.height_m ?? 1.6);
      const typeDbg = (arrayTypeEl.value === "roof") ? "roof" : "waves";
      const tiltDeg = (typeDbg === "waves") ? 12.5 : Number(roofTiltEl.value || "15");
      const rowsDbg = (typeDbg === "waves") ? 18 : Number(roofRowsEl.value || "4");
      const proj = h * Math.cos(tiltDeg * Math.PI / 180.0);
      const approxLen = rowsDbg * proj;
      console.log("[PANEL META]", {
        id: meta.id, name: meta.name, manufacturer: meta.manufacturer,
        width_m: w, height_m: h, thickness_m: Number(meta.thickness_m ?? 0.035),
        rated_power_w: meta.rated_power_w, noct: meta.noct, gamma_pmp: meta.gamma_pmp,
        type: typeDbg, rows: rowsDbg, tiltDeg: tiltDeg,
        approx_projected_row_m: proj, approx_array_len_m: approxLen
      });
    }
  } catch (e) {
    console.warn("[PANEL META] log failed", e);
  }

  // Panels act as occluders for GPU shadow sampling
  panelTemplate.traverse(obj => {
    if (obj && obj.isMesh) {
      obj.castShadow = true;
      obj.receiveShadow = false;
    }
  });

  const elevation = parseFloat(elevationEl.value || "0.6");
  const azDeg = clampAzimuth(parseInt(azimuthEl.value || "180", 10));

          // updateCompass removed (3D north arrow used instead)

  const type = arrayTypeEl.value === "roof" ? "roof" : "waves";
  if (type === "waves") {
    const panelsPerRow = parseInt(wavesPanelsPerRowEl.value || "5", 10);
    buildWavesArray(panelTemplate, panelsPerRow, azDeg, elevation);
  } else {
    const cols = parseInt(roofColsEl.value || "20", 10);
    const rows = parseInt(roofRowsEl.value || "4", 10);
    const tilt = parseFloat(roofTiltEl.value || "15");
    buildRoofArray(panelTemplate, cols, rows, tilt, azDeg, elevation);
  }

  // Capture base panel list before adding any tiled clones
  basePanelMeshes = panelMeshes.slice();

  // Build a detached clone source for tiling (prevents scene graph recursion)
  refreshBaseArrayPrototype();

  // Ground-only: duplicate the array in an X×Y grid (array-of-arrays)
  updateGroundTilingVisibility();
  applyGroundArrayTiling();

  // Resize ground to fit the new geometry (approx. 5m margin)
  updateGroundToArray(5);
  // Update preview sun/shading metric (no UI changes)
  try {
    computeRepresentativeTransmittance("interactive");
  } catch (e) {
    // ignore
  }
  applyRenderModeToScene();
  updateProjectedShadow();
}

      async function fetchSnapshotDay(basePayload) {
        if (!currentLocation || !basePayload) return;
        const resp = await fetch(API_BASE + "/simulate_snapshot_day", {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({
            ...basePayload,
            lat: currentLocation.lat,
            lon: currentLocation.lon
          })
        });
        if (!resp.ok) {
          const txt = await resp.text();
          throw new Error("Snapshot HTTP " + resp.status + ": " + txt);
        }
        const data = await resp.json();
        applySnapshotData(data);
      }

async function runSimulationAndUpdateUI() {
  if (isSimRunning) return;

  // Optional: prevent accidental double-trigger within the same tick burst
  const nowStamp = Date.now();
  if (nowStamp - _simLastRunStamp < 50) return;
  _simLastRunStamp = nowStamp;

  isSimRunning = true;

  const t0 = performance.now();
  const runId = Math.floor(nowStamp);

  // Minimal structured timing
  const T = {
    svf_ms: 0,
    water_samples_ms: 0,
    pv_samples_ms: 0,
    fetch_ms: 0,
    ui_ms: 0,
    total_ms: 0
  };

  try {
    console.groupCollapsed(`▶ runSimulationAndUpdateUI() ${runId}`);

    if (!currentLocation) {
      console.log("No location selected; skipping sim.");
      try { finalizeLocationLoading(); } catch (_) {}
      return;
    }

    const surface = (surfaceTypeEl && surfaceTypeEl.value)
      ? String(surfaceTypeEl.value).toLowerCase()
      : "ground";

    const arrayType = arrayTypeEl.value === "roof" ? "roof" : "waves";
    const azUiDeg = clampAzimuth(parseInt(azimuthEl.value || "180", 10));
    const azDeg = azimuthForBackend(azUiDeg, arrayType);

    const metaIdx = parseInt(panelTypeEl.value || "0", 10);
    const meta = panelsMeta[metaIdx] || panelsMeta[0];
    if (!meta) throw new Error("Panel metadata not loaded.");

    const totalPanels = getCurrentTotalPanels();
    const year = lastFullYear();

    // -------------------------
    // Build base payload
    // -------------------------
    const payload = {
      lat: currentLocation.lat,
      lon: currentLocation.lon,
      array_type: arrayType,
      azimuth_deg: azDeg,
      tilt_deg: arrayType === "waves" ? 12.5 : parseFloat(roofTiltEl.value || "15"),
      total_panels: totalPanels,
      panel_width_m: meta.width_m || 1.0,
      panel_height_m: meta.height_m || 1.6,
      eff_stc: (function () {
        const w = Number(meta.rated_power_w);
        const a = (Number(meta.width_m) || 1.0) * (Number(meta.height_m) || 1.6);
        if (Number.isFinite(w) && w > 0 && Number.isFinite(a) && a > 0) {
          const eff = w / (1000.0 * a);
          return Math.max(0, Math.min(0.30, eff));
        }
        const effMeta = Number(meta.eff_stc);
        return Number.isFinite(effMeta) ? Math.max(0, Math.min(0.30, effMeta)) : undefined;
      })(),
      noct: Number.isFinite(Number(meta.noct)) ? Number(meta.noct) : undefined,
      temp_coeff: (function () {
        const g = Number(meta.gamma_pmp ?? meta.temp_coeff);
        if (!Number.isFinite(g)) return undefined;
        return Math.abs(g) > 0.02 ? (g / 100.0) : g;
      })(),
      cooling_offset: Number.isFinite(Number(meta.cooling_offset)) ? Number(meta.cooling_offset) : undefined
    };

    // Debug export: inspect what we're about to send without needing closures in DevTools
    try {
      window.__lastSimPayload = payload;
      window.__lastTotals = {
        panelMeshes_len: Array.isArray(panelMeshes) ? panelMeshes.length : null,
        totalPanels,
        arrayType,
        surface
      };
    } catch (_) {}

    console.log("[PAYLOAD totals]", {
      panelMeshes_len: Array.isArray(panelMeshes) ? panelMeshes.length : null,
      total_panels: payload.total_panels,
      arrayType,
      surface
    });

    // -------------------------
    // Water-mode: shading samples + SVF
    // Ground-mode: you may still send shading_samples=[], svf=1
    // -------------------------
    let svf = 1.0;
    let shading_samples = [];
    let svf_n_rays = 64;

    if (surface === "water") {
      // 1) water shading samples (GPU shadow-mask proxy)
      const tS0 = performance.now();
      shading_samples = await buildShadingSamplesGPU({
        year,
        lat: currentLocation.lat,
        lon: currentLocation.lon,
        mode: "interactive"
      });
      T.water_samples_ms = performance.now() - tS0;

      // 2) SVF (CPU hemisphere rays)
      svf_n_rays = 64; // keep interactive light; export can use 256
      const tV0 = performance.now();
      try {
        svf = computeSVFCPU(svf_n_rays, 3);
      } catch (e) {
        console.error("[SVF] computeSVFCPU failed", e);
        svf = 0;
      }
      // Debug: confirm SVF immediately after compute
      console.log("[SVF LOCAL]", { svf, svf_n_rays, last: window.__svfLast });
      T.svf_ms = performance.now() - tV0;
    }

    // -------------------------
    // PV self-shading samples (raycast)
    // Do this for both surfaces if you want PV shading always active.
    // If you ONLY want PV shading on water, wrap with (surface === "water").
    // -------------------------
    const tP0 = performance.now();
    let pv_shading_samples = [];
    try {
      pv_shading_samples = await buildPvShadingSamplesRaycast({
        year,
        lat: currentLocation.lat,
        lon: currentLocation.lon,
        mode: "interactive"
      });
      
    } catch (e) {
      console.warn("[PV] buildPvShadingSamplesRaycast failed; continuing without PV shading", e);
      pv_shading_samples = [];
    }
    window.__lastPvSamples = pv_shading_samples;
    T.pv_samples_ms = performance.now() - tP0;

    // One request log per run (helps you verify “only 1 call”)
    console.log("[REQUEST CHECK]", {
      endpoint: "/simulate_shaded",
      surface,
      height_m: Number(elevationEl?.value || 0),
      azimuth_ui_deg: azUiDeg,
      azimuth_sent_deg: azDeg,   // <-- add this
      tilt_deg: arrayType === "waves" ? 12.5 : parseFloat(roofTiltEl.value || "15"),
      svf,
      n_samples: shading_samples?.length || 0,
      pv_samples: pv_shading_samples?.length || 0
    });

    // -------------------------
    // POST simulate_shaded
    // -------------------------
    const water_area_m2 = getWaterAreaM2Safe();
    
    const shadedPayload = {
      ...payload,
      year,
      svf,
      svf_n_rays,
      svf_scheme: (typeof SVF_SCHEME === "string" ? SVF_SCHEME : "hammersley_vdc2_uniform_hemisphere"),
      shading_samples,
      pv_shading_samples,
      surface,
      water_area_m2
    };

    // Debug: confirm SVF + water area in the final outgoing payload
    console.log("[PAYLOAD CHECK]", { svf: shadedPayload.svf, water_area_m2: shadedPayload.water_area_m2 });

    const tF0 = performance.now();
    const resp = await fetch(API_BASE + "/simulate_shaded", {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(shadedPayload)
    });
    T.fetch_ms = performance.now() - tF0;

    if (!resp.ok) {
      const txt = await resp.text();
      throw new Error("HTTP " + resp.status + ": " + txt);
    }

    const data = await resp.json();

    // -------------------------
    // UI update
    // -------------------------
    const tU0 = performance.now();
    try {
      // Keep your existing UI wiring here
      applySimulationResultsToUI(data);
    } catch (e) {
      console.warn("[UI] applySimulationResultsToUI failed", e);
    }
    T.ui_ms = performance.now() - tU0;

    // -------------------------
    // Final timing
    // -------------------------
    T.total_ms = performance.now() - t0;
    console.log("[TIMING]", {
      svf_ms: Math.round(T.svf_ms),
      water_samples_ms: Math.round(T.water_samples_ms),
      pv_samples_ms: Math.round(T.pv_samples_ms),
      fetch_ms: Math.round(T.fetch_ms),
      ui_ms: Math.round(T.ui_ms),
      total_ms: Math.round(T.total_ms),
      svf
    });

  } finally {
    isSimRunning = false;
    try { finalizeLocationLoading(); } catch (_) {}
    console.groupEnd();
  }
}




      function collectPerPanelDataForExport() {
        // Provides a lightweight per-panel audit table for the CURRENT visual state.
        // Includes world position (m), orientation key, and the most recent shading fields if available.
        if (!panelMeshes || !panelMeshes.length) return [];
        const out = [];
        const wp = new THREE.Vector3();
        for (let i = 0; i < panelMeshes.length; i++) {
          const p = panelMeshes[i];
          if (!p) continue;
          p.getWorldPosition(wp);
          out.push({
            idx: i,
            x_m: Number(wp.x.toFixed(4)),
            y_m: Number(wp.y.toFixed(4)),
            z_m: Number(wp.z.toFixed(4)),
            orientation_key: p.userData?.orientationKey ?? null,
            poa_eff_w_m2: Number.isFinite(p.userData?.poa_eff_w_m2) ? Number(p.userData.poa_eff_w_m2) : null,
            tau_beam: Number.isFinite(p.userData?.tau_beam) ? Number(p.userData.tau_beam) : null
          });
        }
        return out;
      }

      async function geocode(query) {
        const url = API_BASE + "/geocode?q=" + encodeURIComponent(query);
        const resp = await fetch(url);
        if (!resp.ok) {
          throw new Error("HTTP " + resp.status);
        }
        return await resp.json();
      }


      async function reverseGeocode(lat, lon, signal) {
        // Cache-bust to avoid any intermediary caching of error responses.
        const url = API_BASE + "/reverse_geocode?lat=" + encodeURIComponent(lat)
          + "&lon=" + encodeURIComponent(lon)
          + "&_ts=" + Date.now();

        const resp = await fetch(url, {
          signal,
          cache: "no-store"
        });

        if (!resp.ok) {
          // Important for debugging: surface the URL that produced 404s.
          const err = new Error("Reverse geocode failed: HTTP " + resp.status);
          err.httpStatus = resp.status;
          err.url = url;
          throw err;
        }
        return await resp.json(); // { provider, display_name, lat, lon }
      }

      let _reverseGeocodeAbort = null;

      let _leafletMap = null;
      let _leafletMarker = null;
      let _locationSelectionInProgress = false;
      let _mapPickRequestId = 0;
      let _mapPickDebounceT = null;

      function _setMapMarker(lat, lon) {
        if (_leafletMarker) {
          _leafletMarker.setLatLng([lat, lon]);
        }
        if (_leafletMap) {
          // keep current zoom if user already zoomed in
          const z = _leafletMap.getZoom();
          _leafletMap.setView([lat, lon], Math.max(z, 3), { animate: true });
        }
      }

      let _simDebounceHandle = null;
      let _simRerunRequested = false;
      let _simLastRunStamp = 0;


      function scheduleSimulation(delayMs = 450) {
        // If SVF is computing, don't re-trigger sim from side-effects.
        if (window.__svfComputing) { _simRerunRequested = true; return; }

        if (_simDebounceHandle) clearTimeout(_simDebounceHandle);

        _simDebounceHandle = setTimeout(async () => {
          _simDebounceHandle = null;

          // If a sim is already running, request exactly ONE rerun afterwards.
          if (isSimRunning) {
            _simRerunRequested = true;
            return;
          }

          await runSimulationAndUpdateUI();

          // If something changed during the run, do ONE more run.
          if (_simRerunRequested) {
            _simRerunRequested = false;
            scheduleSimulation(50);
          }
        }, delayMs);
      }


	      async function pickLatLon(lat, lon, sourceLabel) {
        const reqId = ++_mapPickRequestId;

        // Abort any prior reverse-geocode request to prevent request pile-up and stale UI states.
        try {
          if (_reverseGeocodeAbort) _reverseGeocodeAbort.abort();
        } catch (_) {}
        _reverseGeocodeAbort = new AbortController();

	        _locationSelectionInProgress = true;
	        setLocationLoading(true, "Identifying Location…");

        try {
          const res = await reverseGeocode(lat, lon, _reverseGeocodeAbort.signal);

          // Ignore stale results (user clicked again) without altering current UI state.
          if (reqId !== _mapPickRequestId) return;

          _setMapMarker(lat, lon);

          // apply into existing pipeline (rebuild + scheduleSimulation)
          applyLocationResult(res, res.provider || sourceLabel || "map");

          // keep pill visible until simulation completes (runSimulation -> finalizeLocationLoading)
          setLocationLoading(true, "Data for simulation loading…");
        } catch (err) {
          // If a newer request exists, ignore errors from this one.
          if (reqId !== _mapPickRequestId) return;

          // AbortError is expected during rapid clicking.
          if (err && err.name === "AbortError") return;

          console.error("Map pick failed:", err);
          if (err && err.url) {
            console.warn("Reverse geocode URL:", err.url);
          }

          _locationSelectionInProgress = false;
          setLocationLoading(false);
          if (locationStatusEl) locationStatusEl.textContent = "Location selection failed. Try again.";
        }
      }

      function initMapPicker() {
        if (!mapPickerEl) return;
        if (typeof L === "undefined") {
          console.warn("Leaflet (L) not loaded; map picker disabled.");
          return;
        }
        if (_leafletMap) return;

        const initLat = (currentLocation && Number.isFinite(currentLocation.lat)) ? currentLocation.lat : -33.8688;
        const initLon = (currentLocation && Number.isFinite(currentLocation.lon)) ? currentLocation.lon : 151.2093;

        _leafletMap = L.map(mapPickerEl, {
          worldCopyJump: true,
          zoomControl: true,
          attributionControl: false
        }).setView([initLat, initLon], 2);

        L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
          maxZoom: 19,
          attribution: ""}).addTo(_leafletMap);

        _leafletMarker = L.marker([initLat, initLon], { draggable: true }).addTo(_leafletMap);

        // Click map to select (debounced)
        _leafletMap.on("click", (ev) => {
          const lat = ev.latlng.lat;
          const lon = ev.latlng.lng;
          if (_mapPickDebounceT) clearTimeout(_mapPickDebounceT);
          _mapPickDebounceT = setTimeout(() => pickLatLon(lat, lon, "map"), 150);
        });

        // Drag marker to select (debounced)
        _leafletMarker.on("dragend", () => {
          const ll = _leafletMarker.getLatLng();
          const lat = ll.lat;
          const lon = ll.lng;
          if (_mapPickDebounceT) clearTimeout(_mapPickDebounceT);
          _mapPickDebounceT = setTimeout(() => pickLatLon(lat, lon, "map"), 150);
        });
      }

      function openLocationModal(provider, results) {
        pendingLocationResults = results.slice();
        currentProvider = provider;
        locationModalProvider.textContent = provider;
        locationListEl.innerHTML = "";
        results.forEach((r, idx) => {
          const li = document.createElement("li");
          const id = "loc-" + idx;
          li.innerHTML =
            '<label><input type="radio" name="locationChoice" value="' +
            idx +
            '" ' +
            (idx === 0 ? "checked" : "") +
            ' /> <span>' +
            r.display_name +
            "</span></label>";
          locationListEl.appendChild(li);
        });
        locationModal.style.display = "flex";
      }

      function closeLocationModal() {
        locationModal.style.display = "none";
        pendingLocationResults = [];
      }

function maybeSetEquatorFacingAzimuth() {
  // Optional UX helper: default the array azimuth to face the equator.
  // North hemisphere: face south (180). South hemisphere: face north (0).
  try {    if (!currentLocation || !Number.isFinite(currentLocation.lat)) return;
    const target = currentLocation.lat < 0 ? 0 : 180;
    // Only change if user hasn't intentionally set a different azimuth since load.
    // (We treat any value other than 0/180 as intentional.)
    const cur = parseFloat(azimuthEl?.value || "NaN");
    const isDefaultLike = (cur === 0 || cur === 180 || !Number.isFinite(cur));
    if (isDefaultLike) {
      azimuthEl.value = String(target);
      azimuthValEl.textContent = target + "°";
    }
  } catch (_) {}
}

      function applyLocationResult(res, provider) {
        const latNum = typeof res.lat === "number" ? res.lat : parseFloat(res.lat);
        const lonNum = typeof res.lon === "number" ? res.lon : parseFloat(res.lon);
        currentLocation = { lat: latNum, lon: lonNum, name: res.display_name };
        currentProvider = provider;

        if (Number.isFinite(latNum) && Number.isFinite(lonNum) && typeof _setMapMarker === "function") {
          _setMapMarker(latNum, lonNum);
        }

        if (metricLatEl) metricLatEl.textContent = Number.isFinite(latNum) ? latNum.toFixed(4) : "–";
        if (metricLonEl) metricLonEl.textContent = Number.isFinite(lonNum) ? lonNum.toFixed(4) : "–";
        if (downloadBtn) downloadBtn.disabled = false;
        if (Number.isFinite(latNum) && Number.isFinite(lonNum)) {
          locationStatusEl.textContent = "Selected via " + provider + (res.display_name ? (": " + res.display_name) : ".");
        } else {
          locationStatusEl.textContent = "Selected via " + provider + (res.display_name ? (": " + res.display_name) : ".");
        }
        maybeSetEquatorFacingAzimuth();
        maybeSetEquatorFacingAzimuth();
        rebuildArrayGeometry();
          updateGroundToArray(5);
          if (surfaceTypeEl && surfaceTypeEl.value === "water") invalidateWaterState("arrayChange");
          scheduleSimulation();
      }

      
	function setLocationLoading(isLoading, msg){
	  if (!locationLoadingEl) return;
	  // Show only once a user has started selecting a location.
	  locationLoadingEl.style.display = "flex";
	  locationLoadingEl.classList.toggle("success", !isLoading);
	  // Spinner is hidden automatically in the .success state via CSS.
	  if (locationLoadingTextEl) {
	    if (msg) locationLoadingTextEl.textContent = msg;
		    else locationLoadingTextEl.textContent = isLoading ? "Identifying Location…" : "Location identified";
	  }
	}

	function finalizeLocationLoading() {
	  // Only stop the pill/spinner if a location selection is actually in progress.
	  if (_locationSelectionInProgress) {
	    _locationSelectionInProgress = false;
	    setLocationLoading(false, "Location identified");
	  }
	}



async function searchAndMaybeSelectLocation(query, isInitial = false) {
        const qNorm = (query || "").trim();
        if (!qNorm) return;
        // Prevent repeated prompts / overlapping requests.
        if (geocodeInFlight) return;
        if (!isInitial && currentLocation && qNorm === lastGeocodeQuery && locationModal && locationModal.style.display !== "flex") {
          return;
        }
        lastGeocodeQuery = qNorm;
        geocodeInFlight = true;
        const reqId = ++geocodeRequestId;
        setLocationLoading(true, "Looking up location…");
        locationStatusEl.textContent = "Looking up location…";
        try {
          const data = await geocode(qNorm);
          if (reqId !== geocodeRequestId) return;
          const provider = data.provider || "open-meteo";
          const results = data.results || [];
          if (!results.length) {
            locationStatusEl.textContent = "No results. Try refining the query.";
            return;
          }
          if (results.length === 1 || isInitial) {
            applyLocationResult(results[0], provider);
          } else {
            openLocationModal(provider, results);
          }
        } catch (err) {
          console.error("Geocode error", err);
          locationStatusEl.textContent =
            "Location lookup failed. Please check your network or try again.";
        }
       finally {
          // ensure we always release the in-flight lock
          geocodeInFlight = false;
          setLocationLoading(false);
        }
      }

      function bindEvents() {

        arrayTypeEl.addEventListener("change", () => {
          updateArrayTypeVisibility();

          // Default elevations by array type
          if (arrayTypeEl.value === "roof") {
            elevationEl.value = "4.0";
            elevationValEl.textContent = "4.0 m";
          } else {
            elevationEl.value = "0.6";
            elevationValEl.textContent = "0.6 m";
          }

          maybeSetEquatorFacingAzimuth();
        rebuildArrayGeometry();
          updateGroundToArray(5);
          if (surfaceTypeEl && surfaceTypeEl.value === "water") invalidateWaterState("arrayChange");
          scheduleSimulation();
        });

        panelTypeEl.addEventListener("change", () => {
          updatePanelMetaDisplay();
          maybeSetEquatorFacingAzimuth();
        rebuildArrayGeometry();
          updateGroundToArray(5);
          if (surfaceTypeEl && surfaceTypeEl.value === "water") invalidateWaterState("arrayChange");
          scheduleSimulation();
        });

        wavesPanelsPerRowEl.addEventListener("input", () => {
          wavesPanelsPerRowValEl.textContent = wavesPanelsPerRowEl.value;
          maybeSetEquatorFacingAzimuth();
        rebuildArrayGeometry();
          updateGroundToArray(5);
          if (surfaceTypeEl && surfaceTypeEl.value === "water") invalidateWaterState("arrayChange");
          scheduleSimulation();
        });

        roofColsEl.addEventListener("input", () => {
          roofColsValEl.textContent = roofColsEl.value;
          maybeSetEquatorFacingAzimuth();
        rebuildArrayGeometry();
          updateGroundToArray(5);
          if (surfaceTypeEl && surfaceTypeEl.value === "water") invalidateWaterState("arrayChange");
          scheduleSimulation();
        });

        roofRowsEl.addEventListener("input", () => {
          roofRowsValEl.textContent = roofRowsEl.value;
          maybeSetEquatorFacingAzimuth();
        rebuildArrayGeometry();
          updateGroundToArray(5);
          if (surfaceTypeEl && surfaceTypeEl.value === "water") invalidateWaterState("arrayChange");
          scheduleSimulation();
        });

        roofTiltEl.addEventListener("input", () => {
          roofTiltValEl.textContent = roofTiltEl.value + "°";
          maybeSetEquatorFacingAzimuth();
        rebuildArrayGeometry();
          updateGroundToArray(5);
          if (surfaceTypeEl && surfaceTypeEl.value === "water") invalidateWaterState("arrayChange");
          scheduleSimulation();
        });

        if (azimuthEl && azimuthValEl) {


        azimuthEl.addEventListener("input", () => {
          const val = clampAzimuth(parseInt(azimuthEl.value || "180", 10));
          azimuthEl.value = String(val);
          azimuthValEl.textContent = val + "°";        rebuildArrayGeometry();
          updateGroundToArray(5);
          debugFrames("azimuth input");
          if (surfaceTypeEl && surfaceTypeEl.value === "water") invalidateWaterState("arrayChange");
          scheduleSimulation();
        });
        }

        elevationEl.addEventListener("input", () => {
          const v = parseFloat(elevationEl.value || "0.6");
          elevationValEl.textContent = v.toFixed(1) + " m";
          maybeSetEquatorFacingAzimuth();
          rebuildArrayGeometry();
          updateGroundToArray(5);
          debugFrames("elevation input");
          if (surfaceTypeEl && surfaceTypeEl.value === "water") invalidateWaterState("elevation");
          scheduleSimulation();
        });

        if (waterWidthEl && waterWidthValEl) {
          waterWidthEl.addEventListener("input", () => {
            const v = Math.min(20.0, Math.max(1.0, parseFloat(waterWidthEl.value || "5.0")));
            waterWidthM = v;
            waterWidthValEl.textContent = v.toFixed(1) + " m";
            // Resize the surface plane (center stays fixed) and resimulate so that partial shadowing is respected.
            invalidateWaterState("waterWidth");
            updateGroundToArray(5);
            scheduleSimulation();
          });
        }

        
        // Ground-only array-of-arrays controls
        if (groundArrayXEl && groundArrayXValEl) {
          groundArrayXValEl.textContent = String(parseInt(groundArrayXEl.value || "1", 10));
          groundArrayXEl.addEventListener("input", () => {
            groundArrayXValEl.textContent = String(parseInt(groundArrayXEl.value || "1", 10));
            rebuildArrayGeometry();
            updateGroundToArray(5);
            scheduleSimulation();
          });
        }

        if (groundArrayYEl && groundArrayYValEl) {
          groundArrayYValEl.textContent = String(parseInt(groundArrayYEl.value || "1", 10));
          groundArrayYEl.addEventListener("input", () => {
            groundArrayYValEl.textContent = String(parseInt(groundArrayYEl.value || "1", 10));
            rebuildArrayGeometry();
            updateGroundToArray(5);
            scheduleSimulation();
          });
        }

        updateGroundTilingVisibility();

          surfaceTypeEl.addEventListener("change", () => {
          invalidateWaterState("surfaceType");

          const __surfNow = (surfaceTypeEl && surfaceTypeEl.value) ? String(surfaceTypeEl.value).toLowerCase() : "ground";
          const __ctl = document.getElementById("groundTilingControls");
          if (__ctl) __ctl.style.display = (__surfNow === "ground") ? "" : "none";

          // Reset any ground tiling when switching between Ground/Water.
          // - Over Water: remove clones and keep a single base array.
          // - Back to On Ground: set tiling sliders to 1×1 (user can re-increase).
          try {
            if (groundArrayXEl) { groundArrayXEl.value = "1"; if (groundArrayXValEl) groundArrayXValEl.textContent = "1"; }
            if (groundArrayYEl) { groundArrayYEl.value = "1"; if (groundArrayYValEl) groundArrayYValEl.textContent = "1"; }
          } catch (e) {}
          try { clearGroundTilingClones(); } catch (e) {}
          try { panelMeshes = basePanelMeshes.slice(); } catch (e) {}
          if (currentRenderMode === 'textures') {
            const isWater = surfaceTypeEl.value === "water";
            if (waterWidthRowEl) waterWidthRowEl.style.display = isWater ? "block" : "none";
            if (isWater && waterWidthEl && waterWidthValEl) {
              const v = Math.min(20.0, Math.max(1.0, parseFloat(waterWidthEl.value || String(waterWidthM || 5.0))));
              waterWidthM = v;
              waterWidthEl.value = String(v);
              waterWidthValEl.textContent = v.toFixed(1) + " m";
            }
            updateGroundToArray(5);
            if (shadowOverlayMesh) shadowOverlayMesh.visible = false;
            applyRenderModeToGround();
            scheduleSimulation();
            return;
          }
          // Switch the visual surface and recompute the water metric (if enabled).
          if (groundMesh && groundMesh.material && groundMesh.material.color) {
            const isWater = surfaceTypeEl.value === "water";

            // Toggle water width control visibility
            if (waterWidthRowEl) waterWidthRowEl.style.display = isWater ? "block" : "none";
            if (isWater && waterWidthEl && waterWidthValEl) {
              const v = Math.min(20.0, Math.max(1.0, parseFloat(waterWidthEl.value || String(waterWidthM || 5.0))));
              waterWidthM = v;
              waterWidthEl.value = String(v);
              waterWidthValEl.textContent = v.toFixed(1) + " m";
            }
            
            // Remove any shadow texture when leaving Water mode.
            if (!isWater && groundMesh && groundMesh.material && groundMesh.material.map === groundShadowTexture) {
              groundMesh.material.map = null;
              groundMesh.material.needsUpdate = true;
            }
            // Base tint; simulation pass will still apply irradiance colors.
            groundMesh.material.color.setHex(isWater ? 0x3aa3ff : 0xc3f4f6);
          }
          // Ensure UI reflects Ground-only tiling controls, and rebuild geometry so any prior clones
          // are cleared when switching to Water (or applied again when switching back to Ground).
          updateGroundTilingVisibility();
          rebuildArrayGeometry();

          // Ensure plane continues to fit the array (e.g., after switching array type)
          updateGroundToArray(5);

          // Hide any debug shadow overlay when toggling surface; it can look like a "stuck" duplicate plane.
          if (shadowOverlayMesh) {
            shadowOverlayMesh.visible = false;
          }
          scheduleSimulation();
        });


        if (downloadBtn) {
          downloadBtn.addEventListener("click", async () => {
            try {
              if (!currentLocation) return;

              const surface = (surfaceTypeEl && surfaceTypeEl.value)
                ? String(surfaceTypeEl.value).toLowerCase()
                : "ground";

              // If we are on water, request the backend audit pack ZIP.
              if (surface === "water") {
                downloadBtn.disabled = true;
                if (downloadHint) downloadHint.textContent = "Building shading samples and exporting ZIP…";

                const metaIdx = parseInt(panelTypeEl.value || "0", 10);
                const meta = panelsMeta[metaIdx] || panelsMeta[0];
                if (!meta) throw new Error("Panel metadata not loaded.");

                const arrayType = arrayTypeEl.value === "roof" ? "roof" : "waves";
                const azUiDeg = clampAzimuth(parseInt(azimuthEl.value || "180", 10));
                const azDeg = azimuthForBackend(azUiDeg, arrayType);
                const totalPanels = getCurrentTotalPanels();


                const payload = {
                  lat: currentLocation.lat,
                  lon: currentLocation.lon,
                  array_type: arrayType,
                  azimuth_deg: azDeg,
                  tilt_deg: arrayType === "waves" ? 12.5 : parseFloat(roofTiltEl.value || "15"),
                  total_panels: totalPanels,
                  panel_width_m: meta.width_m || 1.0,
                  panel_height_m: meta.height_m || 1.6,
                  eff_stc: (function () {
                    const w = Number(meta.rated_power_w);
                    const a = (Number(meta.width_m) || 1.0) * (Number(meta.height_m) || 1.6);
                    if (Number.isFinite(w) && w > 0 && Number.isFinite(a) && a > 0) {
                      const eff = w / (1000.0 * a);
                      return Math.max(0, Math.min(0.30, eff));
                    }
                    const effMeta = Number(meta.eff_stc);
                    return Number.isFinite(effMeta) ? Math.max(0, Math.min(0.30, effMeta)) : undefined;
                  })(),
                  noct: Number.isFinite(Number(meta.noct)) ? Number(meta.noct) : undefined,
                  temp_coeff: (function () {
                    const g = Number(meta.gamma_pmp ?? meta.temp_coeff);
                    if (!Number.isFinite(g)) return undefined;
                    return Math.abs(g) > 0.02 ? (g / 100.0) : g;
                  })(),
                  cooling_offset: Number.isFinite(Number(meta.cooling_offset)) ? Number(meta.cooling_offset) : undefined
                };

                console.log("[SIM PAYLOAD CHECK]", {
                  elevEl: elevationEl?.value,
                  height_m: payload.height_m,
                  has_height_m: Object.prototype.hasOwnProperty.call(payload, "height_m"),
                  surface: surfaceTypeEl?.value
                });


                const year = lastFullYear();

                // Higher quality for export pack
                const samples = await buildShadingSamplesGPU({
                  year,
                  lat: currentLocation.lat,
                  lon: currentLocation.lon,
                  mode: "final"
                });

                const svf_n_rays = 256;
                let svf = 0;
            try {
              svf = computeSVFCPU(svf_n_rays);
            } catch (e) {
              console.error("[SVF] computeSVFCPU failed", e);
              svf = 0;
            }

                const shadedPayload = {
                  ...payload,
                  year,
                  svf,
                  svf_n_rays,
                  svf_scheme: (typeof SVF_SCHEME === "string" ? SVF_SCHEME : "hammersley_vdc2_uniform_hemisphere"),
                  shading_samples: samples
                };

                const resp = await fetch(API_BASE + "/export_shaded_run", {
                  method: "POST",
                  headers: { "Content-Type": "application/json" },
                  body: JSON.stringify(shadedPayload)
                });

                if (!resp.ok) {
                  const txt = await resp.text();
                  throw new Error("HTTP " + resp.status + ": " + txt);
                }

                const blob = await resp.blob();
                const url = URL.createObjectURL(blob);

                const a = document.createElement("a");
                a.href = url;
                const safeName = (currentLocation.name || "location").replace(/[^a-z0-9-_]+/gi, "_").slice(0, 60);
                a.download = "sw_audit_pack_" + safeName + "_" + year + ".zip";
                document.body.appendChild(a);
                a.click();
                a.remove();
                URL.revokeObjectURL(url);

                if (downloadHint) downloadHint.textContent = "Audit pack exported.";
              } else {
                // Ground: download latest JSON response (if available)
                const data = window.__lastSimResponse || null;
                if (!data) {
                  if (downloadHint) downloadHint.textContent = "Run a simulation first, then download.";
                  return;
                }
                const perPanel = collectPerPanelDataForExport();
                const exportObj = {
                  ...data,
                  per_panel: perPanel,
                  export_meta: {
                    created_utc: new Date().toISOString(),
                    array_type: (arrayTypeEl && arrayTypeEl.value) ? String(arrayTypeEl.value) : null,
                    surface: surface,
                    snapshot_day: (snapshotData && snapshotData.snapshot_day) ? snapshotData.snapshot_day : null
                  }
                };
                const blob = new Blob([JSON.stringify(exportObj, null, 2)], { type: "application/json" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement("a");
                a.href = url;
                const safeName = (currentLocation.name || "location").replace(/[^a-z0-9-_]+/gi, "_").slice(0, 60);
                a.download = "sw_simulation_" + safeName + ".json";
                document.body.appendChild(a);
                a.click();
                a.remove();
                URL.revokeObjectURL(url);
                if (downloadHint) downloadHint.textContent = "Simulation JSON downloaded.";
              }
            } catch (e) {
              console.error("Download/export failed", e);
              if (downloadHint) downloadHint.textContent = "Download failed: " + (e.message || String(e));
            } finally {
              if (downloadBtn) downloadBtn.disabled = false;
            }
          });
        }
        locationModalCancelBtn.addEventListener("click", () => {
          closeLocationModal();
        });

        locationModalApplyBtn.addEventListener("click", () => {
          const radios = locationListEl.querySelectorAll("input[name='locationChoice']");
          let idx = 0;
          radios.forEach(r => {
            if (r.checked) idx = parseInt(r.value || "0", 10);
          });
          const res = pendingLocationResults[idx];
          if (res) {
            applyLocationResult(res, currentProvider || "open-meteo");
          }
          closeLocationModal();
        });
      }

      async function bootstrap() {
        initThree();
        await loadPanelsMeta();
        updateArrayTypeVisibility();
        
        // Initial: show ground tiling controls only on Ground
        try {
          const __ctl0 = document.getElementById("groundTilingControls");
          const __surf0 = (surfaceTypeEl && surfaceTypeEl.value) ? String(surfaceTypeEl.value).toLowerCase() : "ground";
          if (__ctl0) __ctl0.style.display = (__surf0 === "ground") ? "" : "none";
        } catch(e) {}
        bindEvents();

        window.__SW_DEBUG = {
          dumpTiling: () => (window.__SW_LAST_TILING || null),
          retile: () => { try { applyGroundArrayTiling(); updateGroundToArray(5); } catch (e) { console.error(e); } },
          rebuild: () => { try { rebuildArrayGeometry(); updateGroundToArray(5); } catch (e) { console.error(e); } },
          counts: () => (getGroundTileCounts ? getGroundTileCounts() : {x:1,y:1})
        };


        // Initialize water width control visibility/value
        if (waterWidthRowEl && surfaceTypeEl) {
          const isWater = surfaceTypeEl.value === "water";
          waterWidthRowEl.style.display = isWater ? "block" : "none";
          if (isWater && waterWidthEl && waterWidthValEl) {
            const v = Math.min(20.0, Math.max(1.0, parseFloat(waterWidthEl.value || String(waterWidthM || 5.0))));
            waterWidthM = v;
            waterWidthValEl.textContent = v.toFixed(1) + " m";
          }
        }

        // Build default geometry immediately (white) even before a location is selected
        maybeSetEquatorFacingAzimuth();
        rebuildArrayGeometry();
        updateGroundToArray(5);

        // Default location: Sydney, Australia
        initMapPicker();
        // pick default using reverse geocode so the display name is consistent
        pickLatLon(-33.8688, 151.2093, "default");
      }

      bootstrap();
    })();
  
window.dumpSizes = function dumpSizes() {
  try {
    const lf = window.__lastFootprint;
    if (lf) {
      console.log("[dumpSizes] last footprint (m)", { x: lf.x, z: lf.z, y: lf.y }, "center", lf.center, "surface", lf.surface);
      if (typeof window.currentSurfaceSizeX === "number" && typeof window.currentSurfaceSizeZ === "number") {
        console.log("[dumpSizes] surface plane (m)", { sx: window.currentSurfaceSizeX, sz: window.currentSurfaceSizeZ, area: (window.currentSurfaceSizeX * window.currentSurfaceSizeZ) });
      }
      console.log("[dumpSizes] footprint long axis (m)", Math.max(lf.x || 0, lf.z || 0));
      return;
    }

    const THREE = window.THREE;
    if (!THREE || !window.yawParent || !window.groundMesh || !(window.wavesGroup || window.roofGroup)) {
      console.warn("[dumpSizes] No last footprint cached yet. Trigger any UI change (e.g., move a slider) and try again.");
      return;
    }
    const baseArray = (window.wavesGroup && window.wavesGroup.visible) ? window.wavesGroup : window.roofGroup;
    const prevYaw = window.yawParent.rotation.y;
    window.yawParent.rotation.y = 0;
    window.yawParent.updateMatrixWorld(true);

    const prevGroundVis = window.groundMesh.visible;
    window.groundMesh.visible = false;

    const box = new THREE.Box3().setFromObject(baseArray);
    const sizeW = new THREE.Vector3();
    const centerW = new THREE.Vector3();
    box.getSize(sizeW);
    box.getCenter(centerW);

    window.groundMesh.visible = prevGroundVis;
    window.yawParent.rotation.y = prevYaw;
    window.yawParent.updateMatrixWorld(true);

    console.log("[dumpSizes] array footprint (m)", { x: sizeW.x, z: sizeW.z }, "center", { x: centerW.x, y: centerW.y, z: centerW.z });
    console.log("[dumpSizes] surface plane (m)", { sx: window.currentSurfaceSizeX, sz: window.currentSurfaceSizeZ, area: (window.currentSurfaceSizeX * window.currentSurfaceSizeZ) });
    console.log("[dumpSizes] footprint long axis (m)", Math.max(sizeW.x, sizeW.z));
  } catch (err) {
    console.error("Simulation error", err);
  } finally {
    isSimRunning = false;
  }
};

(function attachRainwaterMetric() {
  const row = document.getElementById("metricWaterCollectedRow");
  const valueEl = document.getElementById("metricWaterCollected");
  if (!valueEl) return;

  const nf0 = new Intl.NumberFormat(undefined, { maximumFractionDigits: 0 });
  const nf1 = new Intl.NumberFormat(undefined, { maximumFractionDigits: 1 });

  function fmt0(x) {
    const v = Number(x);
    return Number.isFinite(v) ? nf0.format(v) : "–";
  }
  function fmt1(x) {
    const v = Number(x);
    return Number.isFinite(v) ? nf1.format(v) : "–";
  }

  // Mirror the app's API base resolution (API_BASE is scoped inside the main IIFE).
  function resolveApiBase() {
    try {
      const qs = new URLSearchParams(window.location.search || "");
      const forced = qs.get("api");
      if (forced) return String(forced).replace(/\/+$/g, "");
    } catch (_) {}

    const host = (window.location && window.location.hostname) ? window.location.hostname : "";
    if (host === "localhost" || host === "127.0.0.1") return "http://127.0.0.1:8000";
    return "https://sw-api-sn0k.onrender.com";
  }

  async function refreshRainwater() {
    try {
      const type = document.getElementById("arrayType")?.value;
      if (type !== "waves") {
        if (row) row.style.display = "none";
        valueEl.textContent = "–";
        return;
      }

      if (row) row.style.display = "";

      const payload = window.__lastSimPayload;
      if (!payload || payload.lat == null || payload.lon == null) {
        valueEl.textContent = "–";
        return;
      }

      const API = resolveApiBase();

      const resp = await fetch(`${API}/rainwater_annual`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload)
      });

      if (!resp.ok) {
        valueEl.textContent = "–";
        return;
      }

      const data = await resp.json();
      if (!data || !data.enabled) {
        valueEl.textContent = "–";
        return;
      }

      const m3 = Number(data.water_collected_m3);
      const L = Number(data.water_collected_liters);
      const y = data.year;

      if (Number.isFinite(m3) && Number.isFinite(L)) {
        valueEl.textContent = `${fmt0(L)} Liters per year`;
      } else {
        valueEl.textContent = "–";
      }
    } catch (e) {
      console.warn("[rainwater] refresh failed", e);
      valueEl.textContent = "–";
    }
  }

  // applySimulationResultsToUI is not on window in this codebase, so we poll
  // for changes in the last sim payload/response instead.
  let lastSig = null;
  function signature() {
    const p = window.__lastSimPayload;
    const r = window.__lastSimResponse;
    if (!p) return null;

    const lat = p.lat, lon = p.lon;
    const at = p.array_type;
    const az = p.azimuth_deg;
    const tt = p.tilt_deg;
    const tp = p.total_panels;
    const pw = p.panel_width_m, ph = p.panel_height_m;
    const hasResp = !!r;
    return [lat, lon, at, az, tt, tp, pw, ph, hasResp].join("|");
  }

  function tick() {
    const sig = signature();
    if (sig && sig !== lastSig) {
      lastSig = sig;
      refreshRainwater();
    }
  }

  const iv = setInterval(tick, 750);
  setTimeout(tick, 600);

  document.getElementById("arrayType")?.addEventListener("change", () => {
    lastSig = null;
    tick();
  });

  window.addEventListener("beforeunload", () => {
    try { clearInterval(iv); } catch (_) {}
  });
})();
</script>
</body>
</html>
